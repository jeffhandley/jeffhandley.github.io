---
layout: post
title: Generics Rule My Proxy
date: '2006-08-23T15:08:00.000-07:00'
author: Jeff Handley
tags: 
modified_time: '2006-08-23T15:08:02.583-07:00'
blogger_id: tag:blogger.com,1999:blog-10056400.post-115637088249447780
blogger_orig_url: http://jeffhandley.blogspot.com/2006/08/generics-rule-my-proxy.html
---

<p>I'm a newbie to Generics and the like.&nbsp; And I'm sure that lots of folks have already been using the approach I'm about to talk about for some time now, but to me... this is freaking cool!</p> <p>My&nbsp;project is the typical client/server situation.&nbsp; The UI will be running on the client, but the Business &amp; Data layers need to run on an application server.&nbsp; I've selected .NET Remoting for my connection framework.</p> <p>In my project skeleton, I laid had put a stub in for a Business.Proxy assembly who would be responsible for doing the .NET Remoting dirty work for me.&nbsp; This would be the single point of entry from the client to the server.</p> <p>On the server, I have a Business.Manager assembly that will house all of my manager classes, where the real work happens.&nbsp; Then I have my Data.Model assembly containing my data entities (generated by LLBLGen).</p> <p>My Presenter layer (MVP/Passive-View) needs to make calls into the server through the Business.Proxy, into the Business.Manager.&nbsp; I expected to have a near 1-to-1 duplication of my Business.Manager classes in my Business.Proxy layer, with the Proxy layer exposing static methods that turned around and called the static methods on the Business.Manager classes, via Remoting.&nbsp; I expected each method in the Proxy to end up being one or two lines of code to make the call.&nbsp; Not too awful at first, but over time this would be a lot of seemingly duplicate code.</p> <p>Well, Generics to the rescue.&nbsp; The alternate approach I came up with this afternoon actually serves the Manager classes up directly to the Presenter, via the Proxy layer.&nbsp; This allows the Presenter to work directly against the Manager classes instead of working against an abstracted copy in the Proxy classes.&nbsp; And best of all, my Proxy layer consists of 1 class with 1 static method, and that's it!&nbsp; Here's the Proxy:</p><!-- code formatted by http://manoli.net/csharpformat/ --><pre class="csharpcode"><span class="kwrd">namespace</span> Business.Proxy<br />{<br />  <span class="kwrd">public</span> <span class="kwrd">class</span> ManagerProxy&lt;Manager&gt;<br />    <span class="kwrd">where</span> Manager : Business.Manager.Common.ManagerBase, <span class="kwrd">new</span>()<br />  {<br />    <span class="kwrd">public</span> <span class="kwrd">static</span> Manager GetManager()<br />    {<br />      RemotingConfiguration.Configure(<br>        <span class="str">"Business.Proxy.dll.config"</span>, <span class="kwrd">false</span>);<br />      <span class="kwrd">return</span> <span class="kwrd">new</span> Manager();<br />    }<br />  }<br />}<br /></pre><br /><p>My calling code from the Presenter looks like this:</p><!-- code formatted by http://manoli.net/csharpformat/ --><pre class="csharpcode">_Manager = ManagerProxy&lt;MyManager&gt;.GetManager();</pre><br /><p>And then my Presenter layer works directly against the manager, except any interactions taken against it happen on the server.&nbsp; This made my day!</p><br /><p>My next step is to see if I can get around having to list all of my managers out in the Remoting config file.</p>