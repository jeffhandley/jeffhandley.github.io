---
layout: post
title: "Custom Controls Everywhere and ASP.NET MVC, part 3"
date: 2008-09-21 01:10:29 -0700
comments: true
category: Archive
tags: []
redirect_from: ["http://jeffhandley.com/archive/2008/09/20/custom-controls-everywhere-and-asp.net-mvc-part-3.aspx"].aspx
author: 0
---
<!-- more -->
<p><em><font color="#ff0000" size="1">Disclaimer: This article and the ideas presented are based on 7-month-old thoughts that have been undeveloped.  While I expect the ideals disclosed are still valid, they might be totally off-base.  I wanted to finish writing this series and share my thoughts, but I've been unable to keep up with the ASP.NET MVC framework.  Please </font><a href="http://blog.jeffhandley.com/archive/2008/09/07/custom-controls-everywhere-and-asp.net-mvc-incomplete.aspx" target="_blank"><font color="#ff0000" size="1">check here</font></a><font color="#ff0000" size="1"> for more information.</font></em></p>  <p><em><font color="#ff0000" size="1">Another Disclaimer: The opinions expressed herein are <b>my</b> <b>own</b> personal opinions <b>and</b> do <b>not</b> represent <b>my</b> <b>employer</b>'s view in any way.  I am not involved in the ASP.NET MVC project.</font></em></p>  <p>This article discusses how I think the ASP.NET MVC framework could be changed to offer better extensibility and customization.  With that said, I think ASP.NET MVC is one of the most extensible frameworks offered by Microsoft.  Its extensibility <a href="http://jeffreypalermo.com/blog/mvccontrib-now-with-subcontroller-support/" target="_blank">has been praised</a>, unlike most other stuff that comes out of Microsoft.  But I think one aspect of the framework has been unintentionally locked down from extensibility and customization--the actual HTML rendering of "controls."</p>  <h2></h2>  <h3>Setting Context</h3>  <p>When I talk about "controls" in this context, I'm not talking about WebForms controls or 3rd party controls like the Infragistics stuff, rather I'm talking about primitive HTML tags like &lt;input&gt; and &lt;select&gt;.  Many of these tags/controls are emitted through the HTML Helpers library, a set of extension methods such as Html.TextBox().  This is where customization and extensibility are taken away.  I discussed this in <a href="http://blog.jeffhandley.com/archive/2008/02/24/custom-controls-everywhere-and-asp.net-mvc-part-1.aspx" target="_blank">part 1</a> of this series.  I think a different approach should have been taken to roll up common controls into shortcuts.</p>  <h3>What I Would Have Done</h3>  <p><a href="http://blog.jeffhandley.com/archive/2008/03/08/custom-controls-everywhere-and-asp.net-mvc-part-2.aspx" target="_blank">Part 2</a> of this series showed how I would implement Custom Controls Everywhere in ASP.NET MVC; essentially, I think that approach should have been promoted in ASP.NET MVC.  Instead of creating an exhaustive library of extension methods that are overloaded like mad, accepting 'object' parameters for anonymous types, fully typed classes should have been created for the different controls.  Instead of having overloaded Html.TextBox() methods, there should be a TextBox class with properties to replace the parameters of the method.  Then, as I demonstrated, the ToString() method on the TextBox class can be responsible for translating the class with its properties into an HTML tag.</p>  <p>My approach also resulted in a base class for MvcControl that handled the raw HTML tag and attributes, allowing a TextBox class to simply define its HTML tag, its properties and how they map to HTML attributes.  This is extremely extensible, because I can create new controls very quickly and easily while still using the shortcut to simply the actual rendering.  With the extension method approach of the HTML Helpers, every extension method is responsible for rendering the HTML, and I suspect there's a lot of duplication going on across the methods and the overloads.</p>  <p>With the TextBox class approach, intellisense is superior to that of the extension methods.  Instead of named parameters into overloads, you can use object initializers and see all possible properties available for the control.  This was illustrated in Part 2 with the following screen shot.</p>  <p><img src="http://blog.jeffhandley.com/Images/PostImages/CustomControlsEverywhereandA.NETMVCpart2_BBEB/image_3.png" /> </p>  <h3>Why (I Think) My Approach is More Extensible and Customizable</h3>  <p>Extensibility and customization is improved with my approach because I can easily add additional behavior to the TextBox by simply deriving from it and adding new properties and optionally overriding ToString().  This still gives you 100% control over how the HTML is rendered, unlike ASP.NET WebForms custom controls, but it offers the rich customizations of WebForms unlike MVC's HTML Helpers.  See, with the HTML Helpers, if I need to slightly tweak the output of an extension method, I cannot derive from it and do so, I must create my own extension methods.  Considering the number of overloads involved in this, in can get completely out of control.</p>  <h3>Composition Over Inheritance</h3>  <p>Having a custom MvcControl class would probably be frowned upon by many.  I was actually just talking with <a href="http://blogs.msdn.com/gblock/" target="_blank">Glenn Block</a> yesterday and he talked about how pattern folks often <a href="http://haacked.com/archive/2007/12/11/favor-composition-over-inheritance-and-other-pithy-catch-phrases.aspx" target="_blank">prefer composition over inheritance</a>.  With that in mind, the custom controls approach can be tweaked slightly to work in a composition mode.  Instead of having a base class, we could easily have a service class that would accept an object, a map of property name to attribute name, and a tag name, and return an HTML tag string.  This service would be called from within the TextBox ToString() method.  This approach would require a little more code in each control, but you would be free to have your own inheritance hierarchy without having to keep MvcControl at the root.  I think the best approach would be to combine the inheritance and composition approaches, offering both by having a static method on MvcControl such as ConvertObjectToTag(object, tagName, propertyAttributeMap).  The ToString() method on MvcControl would use this method itself as well, ensuring consistent results regardless of the approach used.</p>  <h3>What ASP.NET MVC Could Change</h3>  <p>To make my suggestions more concrete, here's a summary of what I would have done differently.  Instead of creating a huge library of extension methods, I would have created classes for the different controls.  This would have been close but not equal to a 1:1 ratio of control to HTML Tag; there'd be slightly more "controls" than HTML tags, since there are cases where 2 or more logical controls map to the same HTML tag.  ListBox and DropDownList are a simple example, where both map to a &lt;select&gt; tag.  Where the extension methods have been overloaded, the classes would have simply had properties added to them, with some occasional conditional logic in the overridden ToString() method.</p>  <p>But ya know what else I would have done?  I would have made the VS templates include a folder chock full of classes, one for each control.  These classes would have derived from the provided control classes, stubbing out the place for you to add your own extensions and customizations to the controls.  Even though it's cheap to create these on your own, it's not encouraged enough.  By stubbing the custom controls out for you, the entrance barrier is torn down and you are shown exactly how and where to manipulate the HTML output of these controls.  The templates would be set up so that your controls would be used in your views rather than those that ship with the framework.  And to really drive the point home, the framework controls could be marked as abstract, forcing you to use your custom controls everywhere, guiding you into the pit of success.</p>  <h3>Closing Statements</h3>  <p>For what it's worth, there's nothing in ASP.NET MVC that prevents this approach from being used; nothing at all.  But what's frustrating is that in order to use this, you have to completely ignore all of the hard work that was put into the HTML Helpers library.  There's a ton of sugar in there that you won't get to benefit from.  If the methods had been build with my approach, you could completely customize your controls where needed, but utilize the default behaviors where that's all you need.</p>  <p>I do wish I had had time to explore these ideas earlier this year, with the opportunity to perhaps build out some of the classes and templates I'm suggesting.  But such is life.  Maybe someone else that supports my ideas here can run with it and add it to the MvcContrib project or something.  Regardless, I am glad to have finally documented my thoughts on this and I hope that some of you find this valuable.</p>  <div class="wlWriterSmartContent" id="scid:0767317B-992E-4b12-91E0-4F059A8CECA8:80e1a819-9679-484f-b023-e7c5c68cd500" style="padding-right: 0px; display: inline; padding-left: 0px; padding-bottom: 0px; margin: 0px; padding-top: 0px">Technorati Tags: <a href="http://technorati.com/tags/ASP.NET" rel="tag">ASP.NET</a>,<a href="http://technorati.com/tags/ASP.NET%20MVC" rel="tag">ASP.NET MVC</a>,<a href="http://technorati.com/tags/Custom%20Controls%20Everywhere" rel="tag">Custom Controls Everywhere</a>,<a href="http://technorati.com/tags/MVC" rel="tag">MVC</a>,<a href="http://technorati.com/tags/MVP" rel="tag">MVP</a>,<a href="http://technorati.com/tags/Object%20Initializers" rel="tag">Object Initializers</a></div>

