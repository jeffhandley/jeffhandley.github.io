---
layout: post
title: "How to safely change 13,000 lines of code, undo"
date: 2008-03-21 05:24:55 -0700
comments: true
category: Archive
tags: []
redirect_from: ["http://jeffhandley.com/archive/2008/03/20/how-to-safely-change-13000-lines-of-code-undo"]
author: 0
---
<!-- more -->
<p>Well, it's too bad.  But we decided today not to finish my <a href="http://blog.jeffhandley.com/archive/2008/02/15/how-to-safely-change-13000-lines-of-code-part-2.aspx" target="_blank">13,000-line change</a> for our nullable value methods.  A bunch of time has gone by since I started this process, and for many reasons, I haven't had the time necessary to devote to completing it.</p>  <p>During the process of working through the different data types, and reviewing the code where the old methods were used, I found that a lot of mistakes have been made.  Luckily though, in most places where mistakes have been made, the code still works just fine.  Often, 2 wrongs have made a right, balancing out the mistakes because the methods are quite forgiving.</p>  <p>The risk with moving forward with the code changes is that we're changing so much code, and affecting so many things.  If we were doing straight-forward search and replace processes, we could minimize the risk.  But since I felt compelled to make sure the new methods would get used correctly, I found myself making hundreds of manual code changes.  I'm sure it would be in the thousands by the time I finished.  Human error now comes into play at a much greater scale.  The global replacement approach was going to be safe because I used TDD to ensure that the new methods provided the same output as the old methods.  But making thousands of changes to screens where we alter the implementation is just too risky.</p>  <p>In addition to the risk, there are some other constraints on my time right now that I can't talk about quite yet.  But let's just say, I don't have a lot of time to devote to this task, and this isn't the kind of thing I'd want to try to hand off mid-stream.</p>  <p>The last thing that comes into play with this decision is our impending platform change.  At some point in the not-to-distant future, we'll be moving DASL to .NET 3.5+.  When we do that, we'll have native nullable types.  We thought this was still years away, but it is looking like we might start the process sooner.  I don't know that it makes much sense to update all of this code and finish implementing .NET 1.1 null handling just in time to move to a new platform that supports nullable values out of the box.</p>  <p>I can't say I'm not disappointed though.  When I started the process, I thought that I'd be able to use TDD to create the new methods, and then use global replacements to get it into place, and end up having changed 13,000 lines of code while incurring minimal risk.  Maybe next time.  Thank god I had been doing all of my work in a Subversion branch.  Nothing was ever committed to trunk.  So we just delete the branch and forget it ever happened.</p>  <div class="wlWriterSmartContent" id="scid:0767317B-992E-4b12-91E0-4F059A8CECA8:149ac5e7-5a0b-4bd6-94a1-7ebbc30f9de6" style="padding-right: 0px; display: inline; padding-left: 0px; float: none; padding-bottom: 0px; margin: 0px; padding-top: 0px">Technorati Tags: <a href="http://technorati.com/tags/Nullable%20Types" rel="tag">Nullable Types</a>,<a href="http://technorati.com/tags/TDD" rel="tag">TDD</a>,<a href="http://technorati.com/tags/Subversion" rel="tag">Subversion</a></div>

