---
layout: post
title: "RIA Services Validation: Custom Reusable Validators"
date: 2010-09-26 10:39:42 -0700
comments: true
category: Archive
tags: []
redirect_from: ["http://jeffhandley.com/archive/2010/09/26/RiaServicesCustomReusableValidators.aspx", "http://jeffhandley.com/archive/2010/09/26/riaservicescustomreusablevalidators.aspx"]
author: 0
---
<!-- more -->
<p>We just covered <a title="RIA Services Validation: Custom Validation Methods" href="/archive/2010/09/25/RiaServicesCustomValidationMethods.aspx" target="_blank">Custom Validation Methods</a>, where we learned how to use <a title="MSDN: CustomValidationAttribute Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.customvalidationattribute.aspx" target="_blank">CustomValidationAttribute</a> to invoke a static (<em>VB: Shared)</em> method to perform validation.  Let’s talk about an alternate approach to custom validation though: creating custom, reusable validators by deriving from <a title="MSDN: ValidationAttribute Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationattribute.aspx" target="_blank">ValidationAttribute</a>.  While it’s true that the custom validation methods used by [CustomValidation] could certainly be reusable, I tend to think of that approach as a light-weight way to call specific business logic routines for validation.  The approach we’re about to see is what I use when I’m creating an inventory of validators to be reused throughout my project(s).</p>  <h3>Deriving from ValidationAttribute</h3>  <p>When you derive from ValidationAttribute, there’s only one method that you must override:    <br /><em>Override this version of IsValid</em></p>  <pre style="margin: auto; font-family: "><font size="2"><font face="Consolas"><span style="margin: auto; color: "><font color="#0000ff">protected</font></span><font color="#000000"> </font><span style="margin: auto; color: "><font color="#0000ff">override</font></span><font color="#000000"> </font><span style="margin: auto; color: "><font color="#2b91af">ValidationResult</font></span><font color="#000000"> IsValid(</font><span style="margin: auto; color: "><font color="#0000ff">object</font></span><font color="#000000"> value, </font><span style="margin: auto; color: "><font color="#2b91af">ValidationContext</font></span><font color="#000000"> validationContext)</font></font><br /></font></pre>

<p><font size="2" />

  </p><p>This version of the IsValid method was added in .NET 4.0, as part of our work in RIA Services.  The method accepts a <a title="MSDN: ValidationContext Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationcontext.aspx" target="_blank">ValidationContext</a> and returns a <a title="MSDN: ValidationResult Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationresult(VS.95).aspx" target="_blank">ValidationResult</a>, both of which were also added as part of our efforts.  The validation context allows the validator to understand the context in which it’s being invoked.  Information such as the <a title="MSDN: ValidationContext.ObjectInstance Property" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationcontext.objectinstance(VS.95).aspx" target="_blank">ObjectInstance</a> (entity), its type, the <a title="MSDN: ValidationContext.MemberName Property" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationcontext.membername(VS.95).aspx" target="_blank">MemberName</a> being validated, and its <a title="MSDN: ValidationContext.DisplayName Property" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationcontext.displayname(VS.95).aspx" target="_blank">DisplayName</a> are now available.  Before ValidationContext was introduced, validators had no clue under what conditions they were being invoked—they merely had the value to validate.  Now that we have ValidationContext, it becomes possible to check other state on the object, which is a very common scenario I call <strong>cross-field validation</strong>.</p>

  <p>Note that ValidationAttribute has another virtual IsValid method that has the following signature: 
    <br /><em>Don’t override this version of IsValid</em></p>

  <pre style="margin: auto; font-family: "><font face="Consolas"><font size="2"><span style="margin: auto; color: "><font color="#0000ff">public</font></span><font color="#000000"> </font><span style="margin: auto; color: "><font color="#0000ff">override</font></span><font color="#000000"> </font><span style="margin: auto; color: "><font color="#0000ff">bool</font></span><font color="#000000"> IsValid(</font><span style="margin: auto; color: "><font color="#0000ff">object</font></span><font color="#000000"> value)</font></font></font><br /></pre>

  <p> </p>

  <p>This is the legacy form (from waaay back in .NET 3.5 days &lt;smirk&gt;).  As you can see, that method cannot glean any state and therefore its applications are quite limited.  In fact, when I ported ValidationAttribute to Silverlight, I made the decision to make this overload of IsValid internal instead of protected.  This helps you avoid accidentally overriding this version of the method, while still allowing the standard validators (that don’t need ValidationContext) to override it.</p>

  <p><em>Aside: For a fun programming challenge – Figure out how ValidationAttribute can determine which version of IsValid has been overridden and should therefore be called during validation.</em></p>

  <h3>Single-Field Validation Example: DateValidatorAttribute</h3>

  <p>While the <a title="RIA Services Validation: Standard Validators" href="/archive/2010/09/22/RiaServicesStandardValidators.aspx" target="_blank">standard validators</a> cover many validation scenarios for scalar values, there are still plenty of single-value custom validation scenarios out there.  In the scenario of scheduling a meeting for example, we want to ensure that the meeting is scheduled in the future, and not the past.  Such a validator only needs to know the value being validated (and the current date)—it doesn’t need access to the rest of the entity, or any other context to decide whether or not the value is valid.</p>

  <p>Date validation isn’t unique to meeting times though; many other dates need to be validated too.  Direct deposit change dates must also be in the future, while birth dates are always in the past.  When we recognize that date type validation is going to be common throughout our application, it’s time to write a custom, reusable validator.  Let’s derive from ValidationAttribute to do it.</p>

  <div id="codeSnippetWrapper">
    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"><span style="color: #0000ff">using</span> System;<br /><span style="color: #0000ff">using</span> System.ComponentModel.DataAnnotations;<br /> <br /><span style="color: #0000ff">namespace</span> RudeValidation.Web.Validators<br />{<br />    <span style="color: #008000">/// &lt;summary&gt;</span><br />    <span style="color: #008000">/// Support two types of date validation:</span><br />    <span style="color: #008000">/// 1) Ensure dates are in the past</span><br />    <span style="color: #008000">/// 2) Ensure dates are in the future</span><br />    <span style="color: #008000">/// &lt;/summary&gt;</span><br />    <span style="color: #008000">/// &lt;remarks&gt;</span><br />    <span style="color: #008000">/// No date can ever be the present for more</span><br />    <span style="color: #008000">/// than an instant.</span><br />    <span style="color: #008000">/// &lt;/remarks&gt;</span><br />    <span style="color: #0000ff">public</span> <span style="color: #0000ff">enum</span> DateValidatorType<br />    {<br />        Past,<br />        Future<br />    }<br /> <br />    <span style="color: #008000">/// &lt;summary&gt;</span><br />    <span style="color: #008000">/// Validate that a date value is either a Past or Future date</span><br />    <span style="color: #008000">/// as appropriate.</span><br />    <span style="color: #008000">/// &lt;/summary&gt;</span><br />    <span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> DateValidatorAttribute : ValidationAttribute<br />    {<br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// The type of date expected.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #0000ff">public</span> DateValidatorType ValidatorType { get; <span style="color: #0000ff">private</span> set; }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// Validate that a date value is either a Past or Future date</span><br />        <span style="color: #008000">/// as appropriate.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #008000">/// &lt;param name="validatorType"&gt;&lt;/param&gt;</span><br />        <span style="color: #0000ff">public</span> DateValidatorAttribute(DateValidatorType validatorType)<br />        {<br />            <span style="color: #0000ff">this</span>.ValidatorType = validatorType;<br />        }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// Conditionally validate that the date is either in the past</span><br />        <span style="color: #008000">/// or in the future.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #008000">/// &lt;param name="value"&gt;The date to validate.&lt;/param&gt;</span><br />        <span style="color: #008000">/// &lt;param name="validationContext"&gt;The validation context.&lt;/param&gt;</span><br />        <span style="color: #008000">/// &lt;returns&gt;</span><br />        <span style="color: #008000">/// &lt;see cref="ValidationResult.Success"/&gt; when the date matches the</span><br />        <span style="color: #008000">/// expected date type, otherwise a &lt;see cref="ValidationResult"/&gt;.</span><br />        <span style="color: #008000">/// &lt;/returns&gt;</span><br />        <span style="color: #0000ff">protected</span> <span style="color: #0000ff">override</span> ValidationResult IsValid(<span style="color: #0000ff">object</span> <span style="color: #0000ff">value</span>,<br />            ValidationContext validationContext)<br />        {<br />            DateTime date = (DateTime)<span style="color: #0000ff">value</span>;<br />            <span style="color: #0000ff">int</span> comparison = date.CompareTo(DateTime.Now);<br /> <br />            <span style="color: #0000ff">if</span> (comparison &lt; 0)<br />            {<br />                <span style="color: #0000ff">if</span> (<span style="color: #0000ff">this</span>.ValidatorType != Validators.DateValidatorType.Past)<br />                {<br />                    <span style="color: #0000ff">return</span> <span style="color: #0000ff">new</span> ValidationResult(<br />                        <span style="color: #0000ff">string</span>.Format(<span style="color: #006080">"{0} cannot be in the past"</span>, validationContext.DisplayName),<br />                        <span style="color: #0000ff">new</span>[] { validationContext.MemberName });<br />                }<br />            }<br />            <span style="color: #0000ff">else</span> <span style="color: #0000ff">if</span> (comparison &gt; 0)<br />            {<br />                <span style="color: #0000ff">if</span> (<span style="color: #0000ff">this</span>.ValidatorType != Validators.DateValidatorType.Future)<br />                {<br />                    <span style="color: #0000ff">return</span> <span style="color: #0000ff">new</span> ValidationResult(<br />                        <span style="color: #0000ff">string</span>.Format(<span style="color: #006080">"{0} cannot be in the future"</span>, validationContext.DisplayName),<br />                        <span style="color: #0000ff">new</span>[] { validationContext.MemberName });<br />                }<br />            }<br /> <br />            <span style="color: #0000ff">return</span> ValidationResult.Success;<br />        }<br />    }<br />}</pre>

    <br /></div>

  <pre style="margin: auto; font-family: "> </pre>

  <p><em><strong>Be sure to save this in a file with .shared.cs in its file name, to inform RIA Services that the file should be cross-compiled to Silverlight as well.</strong></em></p>

  <p>That’s a decent amount of code, but mostly because it has copious comments and line breaks.  As I’m sure you’ve decided though: it’s not rocket science.  You might have taken note that we did end up utilizing the ValidationContext within our validation though, so that we could generate a user-friendly error message that references the DisplayName of the property being validated.  <em>Note, that’s the DisplayName, not the MemberName, that is being injected into the error message. The MemberName is used too, but not for user-facing display.</em></p>

  <h3>Cross-Field Validation Example: ConditionallyRequiredAttribute</h3>

  <p>When I get a meeting invite for a meeting that will last more than an hour, I expect to see some sort of agenda in the meeting details; don’t you?  And there’s a conference room on our floor that no one can ever find, it’s room 18/3367.  Anytime anyone schedules a meeting in that room, they should be required to put directions into the meeting invite.  These types of business rules come up often: “Anytime user does X, require them to do Y.”  We need a Conditionally Required validator.  Let’s see what we can come up with.</p>

  <div id="codeSnippetWrapper">
    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"><span style="color: #0000ff">using</span> System;<br /><span style="color: #0000ff">using</span> System.ComponentModel.DataAnnotations;<br /><span style="color: #0000ff">using</span> System.Linq;<br /><span style="color: #0000ff">using</span> System.Reflection;<br /> <br /><span style="color: #0000ff">namespace</span> RudeValidation.Web.Validators<br />{<br />    <span style="color: #008000">/// &lt;summary&gt;</span><br />    <span style="color: #008000">/// Make a member required under a certain condition.</span><br />    <span style="color: #008000">/// &lt;/summary&gt;</span><br />    <span style="color: #008000">/// &lt;remarks&gt;</span><br />    <span style="color: #008000">/// Override the attribute usage to allow multiple attributes to be applied.</span><br />    <span style="color: #008000">/// This requires that the TypeId property be overridden on the desktop framework.</span><br />    <span style="color: #008000">/// &lt;/remarks&gt;</span><br />    [AttributeUsage(<br />        AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Parameter,<br />        AllowMultiple = <span style="color: #0000ff">true</span>)]<br />    <span style="color: #0000ff">public</span> <span style="color: #0000ff">class</span> ConditionallyRequiredAttribute : RequiredAttribute<br />    {<br />        <span style="color: #0000ff">private</span> MemberInfo _member;<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// The name of the member that will return the state that indicates</span><br />        <span style="color: #008000">/// whether or not the validated member is required.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #0000ff">public</span> <span style="color: #0000ff">string</span> ConditionMember { get; <span style="color: #0000ff">private</span> set; }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// The condition value under which this validator treats</span><br />        <span style="color: #008000">/// the affected member as required.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #0000ff">public</span> <span style="color: #0000ff">object</span> RequiredCondition { get; <span style="color: #0000ff">private</span> set; }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// Comma-separated list of additional members to</span><br />        <span style="color: #008000">/// add to validation errors.  By default, the</span><br />        <span style="color: #008000">/// &lt;see cref="ConditionMember"/&gt; is added.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #0000ff">public</span> <span style="color: #0000ff">string</span> ErrorMembers { get; set; }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// Conditionally require a value, only when the specified</span><br />        <span style="color: #008000">/// &lt;paramref name="conditionMember"/&gt; is &lt;c&gt;true&lt;/c&gt;.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #008000">/// &lt;param name="conditionMember"&gt;</span><br />        <span style="color: #008000">/// The member that must be &lt;c&gt;true&lt;/c&gt; to require a value.</span><br />        <span style="color: #008000">/// &lt;/param&gt;</span><br />        <span style="color: #0000ff">public</span> ConditionallyRequiredAttribute(<span style="color: #0000ff">string</span> conditionMember)<br />            : <span style="color: #0000ff">this</span>(conditionMember, <span style="color: #0000ff">true</span>) { }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// Conditionally require a value, only when the specified</span><br />        <span style="color: #008000">/// &lt;paramref name="conditionMember"/&gt; has a value that</span><br />        <span style="color: #008000">/// exactly matches the &lt;paramref name="requiredCondition"/&gt;.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #008000">/// &lt;param name="conditionMember"&gt;</span><br />        <span style="color: #008000">/// The member that will be evaluated to require a value.</span><br />        <span style="color: #008000">/// &lt;/param&gt;</span><br />        <span style="color: #008000">/// &lt;param name="requiredCondition"&gt;</span><br />        <span style="color: #008000">/// The value the &lt;paramref name="conditionMember"/&gt; must</span><br />        <span style="color: #008000">/// hold to require a value.</span><br />        <span style="color: #008000">/// &lt;/param&gt;</span><br />        <span style="color: #0000ff">public</span> ConditionallyRequiredAttribute(<span style="color: #0000ff">string</span> conditionMember, <span style="color: #0000ff">object</span> requiredCondition)<br />        {<br />            <span style="color: #0000ff">this</span>.ConditionMember = conditionMember;<br />            <span style="color: #0000ff">this</span>.RequiredCondition = requiredCondition;<br />            <span style="color: #0000ff">this</span>.ErrorMembers = <span style="color: #0000ff">this</span>.ConditionMember;<br />        }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// Override the base validation to only perform validation when the required</span><br />        <span style="color: #008000">/// condition has been met.  In the case of validation failure, augment the</span><br />        <span style="color: #008000">/// validation result with the &lt;see cref="ErrorMembers"/&gt; as an additional</span><br />        <span style="color: #008000">/// member names, as needed.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #008000">/// &lt;param name="value"&gt;The value being validated.&lt;/param&gt;</span><br />        <span style="color: #008000">/// &lt;param name="validationContext"&gt;The validation context being used.&lt;/param&gt;</span><br />        <span style="color: #008000">/// &lt;returns&gt;</span><br />        <span style="color: #008000">/// &lt;see cref="ValidationResult.Success"/&gt; if not currently required or if satisfied,</span><br />        <span style="color: #008000">/// or a &lt;see cref="ValidationResult"/&gt; in the case of failure.</span><br />        <span style="color: #008000">/// &lt;/returns&gt;</span><br />        <span style="color: #0000ff">protected</span> <span style="color: #0000ff">override</span> ValidationResult IsValid(<span style="color: #0000ff">object</span> <span style="color: #0000ff">value</span>, ValidationContext validationContext)<br />        {<br />            <span style="color: #0000ff">if</span> (<span style="color: #0000ff">this</span>.DiscoverMember(validationContext.ObjectType))<br />            {<br />                <span style="color: #0000ff">object</span> state = <span style="color: #0000ff">this</span>.InvokeMember(validationContext.ObjectInstance);<br /> <br />                <span style="color: #008000">// We are only required if the current state</span><br />                <span style="color: #008000">// matches the specified condition.</span><br />                <span style="color: #0000ff">if</span> (Object.Equals(state, <span style="color: #0000ff">this</span>.RequiredCondition))<br />                {<br />                    ValidationResult result = <span style="color: #0000ff">base</span>.IsValid(<span style="color: #0000ff">value</span>, validationContext);<br /> <br />                    <span style="color: #0000ff">if</span> (result != ValidationResult.Success &amp;&amp; <span style="color: #0000ff">this</span>.ErrorMembers != <span style="color: #0000ff">null</span> &amp;&amp; <span style="color: #0000ff">this</span>.ErrorMembers.Any())<br />                    {<br />                        result = <span style="color: #0000ff">new</span> ValidationResult(result.ErrorMessage,<br />                            result.MemberNames.Union(<span style="color: #0000ff">this</span>.ErrorMembers.Split(<span style="color: #006080">','</span>).Select(s =&gt; s.Trim())));<br />                    }<br /> <br />                    <span style="color: #0000ff">return</span> result;<br />                }<br /> <br />                <span style="color: #0000ff">return</span> ValidationResult.Success;<br />            }<br /> <br />            <span style="color: #0000ff">throw</span> <span style="color: #0000ff">new</span> InvalidOperationException(<br />                <span style="color: #006080">"ConditionallyRequiredAttribute could not discover member: "</span> + <span style="color: #0000ff">this</span>.ConditionMember);<br />        }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// Discover the member that we will evaluate for checking our condition.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #008000">/// &lt;param name="objectType"&gt;&lt;/param&gt;</span><br />        <span style="color: #008000">/// &lt;returns&gt;&lt;/returns&gt;</span><br />        <span style="color: #0000ff">private</span> <span style="color: #0000ff">bool</span> DiscoverMember(Type objectType)<br />        {<br />            <span style="color: #0000ff">if</span> (<span style="color: #0000ff">this</span>._member == <span style="color: #0000ff">null</span>)<br />            {<br />                <span style="color: #0000ff">this</span>._member = (from member <span style="color: #0000ff">in</span> objectType.GetMember(<span style="color: #0000ff">this</span>.ConditionMember).Cast&lt;MemberInfo&gt;()<br />                                <span style="color: #0000ff">where</span> IsSupportedProperty(member) || IsSupportedMethod(member)<br />                                select member).SingleOrDefault();<br />            }<br /> <br />            <span style="color: #008000">// If we didn't find 1 exact match, indicate that we could not discover the member</span><br />            <span style="color: #0000ff">return</span> <span style="color: #0000ff">this</span>._member != <span style="color: #0000ff">null</span>;<br />        }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// Determine if a &lt;paramref name="member"/&gt; is a</span><br />        <span style="color: #008000">/// method that accepts no parameters.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #008000">/// &lt;param name="member"&gt;The member to check.&lt;/param&gt;</span><br />        <span style="color: #008000">/// &lt;returns&gt;</span><br />        <span style="color: #008000">/// &lt;c&gt;true&lt;/c&gt; if the member is a parameterless method.</span><br />        <span style="color: #008000">/// Otherwise, &lt;c&gt;false&lt;/c&gt;.</span><br />        <span style="color: #008000">/// &lt;/returns&gt;</span><br />        <span style="color: #0000ff">private</span> <span style="color: #0000ff">bool</span> IsSupportedMethod(MemberInfo member)<br />        {<br />            <span style="color: #0000ff">if</span> (member.MemberType != MemberTypes.Method)<br />            {<br />                <span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span>;<br />            }<br /> <br />            MethodInfo method = (MethodInfo)member;<br />            <span style="color: #0000ff">return</span> method.GetParameters().Length == 0<br />                &amp;&amp; method.GetGenericArguments().Length == 0<br />                &amp;&amp; method.ReturnType != <span style="color: #0000ff">typeof</span>(<span style="color: #0000ff">void</span>);<br />        }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// Determine if a &lt;paramref name="member"/&gt; is a</span><br />        <span style="color: #008000">/// property that has no indexer.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #008000">/// &lt;param name="member"&gt;The member to check.&lt;/param&gt;</span><br />        <span style="color: #008000">/// &lt;returns&gt;</span><br />        <span style="color: #008000">/// &lt;c&gt;true&lt;/c&gt; if the member is a non-indexed property.</span><br />        <span style="color: #008000">/// Otherwise, &lt;c&gt;false&lt;/c&gt;.</span><br />        <span style="color: #008000">/// &lt;/returns&gt;</span><br />        <span style="color: #0000ff">private</span> <span style="color: #0000ff">bool</span> IsSupportedProperty(MemberInfo member)<br />        {<br />            <span style="color: #0000ff">if</span> (member.MemberType != MemberTypes.Property)<br />            {<br />                <span style="color: #0000ff">return</span> <span style="color: #0000ff">false</span>;<br />            }<br /> <br />            PropertyInfo property = (PropertyInfo)member;<br />            <span style="color: #0000ff">return</span> property.GetIndexParameters().Length == 0;<br />        }<br /> <br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// Invoke the member and return its value.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #008000">/// &lt;param name="objectInstance"&gt;The object to invoke against.&lt;/param&gt;</span><br />        <span style="color: #008000">/// &lt;returns&gt;The member's return value.&lt;/returns&gt;</span><br />        <span style="color: #0000ff">private</span> <span style="color: #0000ff">object</span> InvokeMember(<span style="color: #0000ff">object</span> objectInstance)<br />        {<br />            <span style="color: #0000ff">if</span> (<span style="color: #0000ff">this</span>._member.MemberType == MemberTypes.Method)<br />            {<br />                MethodInfo method = (MethodInfo)<span style="color: #0000ff">this</span>._member;<br />                <span style="color: #0000ff">return</span> method.Invoke(objectInstance, <span style="color: #0000ff">null</span>);<br />            }<br /> <br />            PropertyInfo property = (PropertyInfo)<span style="color: #0000ff">this</span>._member;<br />            <span style="color: #0000ff">return</span> property.GetValue(objectInstance, <span style="color: #0000ff">null</span>);<br />        }<br /> <br /><span style="color: #cc6633">#if</span> !SILVERLIGHT<br />        <span style="color: #008000">/// &lt;summary&gt;</span><br />        <span style="color: #008000">/// The desktop framework has this property and it must be</span><br />        <span style="color: #008000">/// overridden when allowing multiple attributes, so that</span><br />        <span style="color: #008000">/// attribute instances can be disambiguated based on</span><br />        <span style="color: #008000">/// field values.</span><br />        <span style="color: #008000">/// &lt;/summary&gt;</span><br />        <span style="color: #0000ff">public</span> <span style="color: #0000ff">override</span> <span style="color: #0000ff">object</span> TypeId<br />        {<br />            get { <span style="color: #0000ff">return</span> <span style="color: #0000ff">this</span>; }<br />        }<br /><span style="color: #cc6633">#endif</span><br />    }<br />}</pre>
  </div>

  <p><em><strong>
        <br />Be sure to save this in a file with .shared.cs in its file name, to inform RIA Services that the file should be cross-compiled to Silverlight as well.</strong></em></p>

  <p>Well, that’s a relatively beefy validation attribute implementation.  Again, it’s not complicated though; this validator simply requires a little bit of code, and again there are lots of comments and much whitespace.  Let’s break it down.</p>

  <ol>
    <li>Inherit from <a title="MSDN: RequiredAttribute Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.requiredattribute.aspx" target="_blank">RequiredAttribute</a> (instead of ValidationAttribute directly), to reuse the logic already in place; </li>

    <li>Override the attribute usage to allow multiple instances of this attribute to be applied to a member; </li>

    <li>The <strong>ConditionMember</strong> property is the string member name that indicates what property to check for the required condition; </li>

    <li>The <strong>RequiredCondition</strong> property is the value that makes the field become required; </li>

    <li>The <strong>ErrorMembers</strong> property allows additional members to be added to the validation result (see “ValidationResult Member Names” below); </li>

    <li>The first constructor accepts only the condition member, and it defaults the required condition to <strong><em>true</em></strong>, which will be very common in practice; </li>

    <li>The second constructor accepts both the condition member and the required condition; (we’ll use this for specifying that meeting details are required for a specific location); </li>

    <li>The <a title="MSDN: ValidationAttribute.IsValid Method" href="http://msdn.microsoft.com/en-us/library/dd730022.aspx" target="_blank">IsValid</a> override tries to discover the condition member; if it cannot discover it, we throw an exception (see “Bad Attribute Declarations” below); </li>

    <li>If the member was discovered, the member is invoked and the current state is compared to the required condition </li>

    <li>If (and only if) the current state indicates that a value is required, we call the base validator; </li>

    <li>DiscoverMember, IsSupportedMethod, IsSupportedProperty, and InvokeMember are reflection methods for finding and invoking the specified member using the ConditionMember string provided, the <strong>ValidationContext.ObjectType</strong>, and <strong>ValidationContext.ObjectInstance</strong>; </li>

    <li>TypeId must be overridden on the desktop framework to tell TypeDescriptionProvider to disambiguate attribute instances using their fields, since we are now allowing multiple instances of the attribute type to be applied to a single member. </li>
  </ol>

  <p> </p>

  <h4>ValidationResult Member Names</h4>

  <p>As mentioned above, when this validation fails, we are adding the ErrorMembers to the MemberNames for the ValidationResult.  We do this for two reasons:</p>

  <ol>
    <li>It causes the ConditionMember (or other specified members) to be highlighted when an error occurs; </li>

    <li>It forces the validation error to be cleared when any field involved is updated. </li>
  </ol>

  <p>The first reason is really just about usability, but the second point is more interesting.  Consider the following scenario:</p>

  <ol>
    <li>Enter a Location of “18/3367” </li>

    <li>Leave the Details field blank and get a validation error stating that a meeting in this room requires directions to be included in the details; </li>

    <li>Revise the Location and choose a different room; </li>

    <li><em>We expect the validation error to go away.  If Location wasn’t a member of the ValidationResult, then the error would persist.</em> </li>
  </ol>

  <p>Let’s consider our other scenario too.</p>

  <ol>
    <li>Enter a Start time of 12:00 PM; </li>

    <li>Enter an End time of 2:00 PM; </li>

    <li>Leave the Details field blank and get a validation error stating that an agenda is required; </li>

    <li>Revise either the Start time or End time, or fill in an agenda; </li>

    <li><em>We expect the validation error to go away regardless of how it was corrected. All three fields must be in the ValidationResult.MemberNames array to achieve that.</em> </li>
  </ol>

  <h4>Bad Attribute Declarations</h4>

  <p>When creating custom validation attributes, you will often have scenarios where the developer did not declare the attribute properly, and your attribute code needs to deal with it.  Your instinct will be to throw exceptions from either your attribute constructor or the property setters.  However, doing either of those is bad news in an attribute.  You can bring lots of things down if exceptions are thrown trying to construct attribute instances at <em>design-time</em>.  For instance, when you build your project, RIA Services reads the metadata from your model and performs code generation to make your entities available in Silverlight.  If your project contains an attribute declaration that throws an exception while we’re trying to do this code generation, you will end up with misleading build errors—there’s just no way around it.</p>

  <p>So, what you must do with bad attribute declarations, is throw exceptions at <em>run-time</em>.  In this example, I’m throwing an InvalidOperationException from the IsValid method, which will bring down the Silverlight application with an unhandled exception as soon as validation is performed against the field that has a bad validator applied.</p>

  <h3>Applying Custom Reusable Validators</h3>

  <p>Custom validators that derive from ValidationAttribute apply to your model in the same way as standard validators.  Let’s take a look at how the specific above attributes can be applied to our Meeting entity though.  This entity and its validation have been carried over from our <a title="RIA Services Validation: Custom Validation Methods" href="/archive/2010/09/25/RiaServicesCustomValidationMethods.aspx" target="_blank">previous post</a>, but I’ve <font style="background-color: #ffff00">highlighted</font> the newly added lines.</p>

  <div id="codeSnippetWrapper">
    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"><span style="color: #0000ff">using</span> System;<br /><span style="color: #0000ff">using</span> System.ComponentModel.DataAnnotations;<br /><span style="color: #0000ff">using</span> RudeValidation.Web.Resources;<br /><span style="color: #0000ff">using</span> RudeValidation.Web.Validators;<br /> <br /><span style="color: #0000ff">namespace</span> RudeValidation.Web.Models<br />{<br />    <span style="color: #0000ff">public</span> <span style="color: #0000ff">partial</span> <span style="color: #0000ff">class</span> Meeting<br />    {<br />        [Key]<br />        <span style="color: #0000ff">public</span> <span style="color: #0000ff">int</span> MeetingId { get; set; }<br /> <br />        [Required]<br />        [CustomValidation(<span style="color: #0000ff">typeof</span>(MeetingValidators), <span style="color: #006080">"NoEarlyMeetings"</span>)]<br /><font style="background-color: #ffff00">        [DateValidator(DateValidatorType.Future)]</font><br />        <span style="color: #0000ff">public</span> DateTime Start { get; set; }<br /> <br />        [Required]<br />        <span style="color: #0000ff">public</span> DateTime End { get; set; }<br /> <br />        [Required]<br />        [StringLength(80, MinimumLength = 5,<br />            ErrorMessageResourceType = <span style="color: #0000ff">typeof</span>(ValidationErrorResources),<br />            ErrorMessageResourceName = <span style="color: #006080">"TitleStringLengthErrorMessage"</span>)]<br />        <span style="color: #008000">// {0} must be at least {2} characters and no more than {1}.</span><br />        <span style="color: #0000ff">public</span> <span style="color: #0000ff">string</span> Title { get; set; }<br /> <br /><font style="background-color: #ffff00">        [ConditionallyRequired(<span style="color: #006080">"IsLongMeeting"</span>,<br />            ErrorMembers = <span style="color: #006080">"Start, End"</span>,<br />            ErrorMessage = <span style="color: #006080">"If you're asking for more than an hour of time, provide an agenda."</span>)]<br />        [ConditionallyRequired(<span style="color: #006080">"Location"</span>, <span style="color: #006080">"18/3367"</span>,<br />            ErrorMessage = <span style="color: #006080">"No one can ever find this room; please be sure to include directions."</span>)]<br /></font>        <span style="color: #0000ff">public</span> <span style="color: #0000ff">string</span> Details { get; set; }<br /> <br />        [Required]<br />        [RegularExpression(<span style="color: #006080">@"\d{1,3}/\d{4}"</span>,<br />            ErrorMessage = <span style="color: #006080">"{0} must be in the format of 'Building/Room'"</span>)]<br />        <span style="color: #0000ff">public</span> <span style="color: #0000ff">string</span> Location { get; set; }<br /> <br />        [Range(2, 100)]<br />        [Display(Name = <span style="color: #006080">"Minimum Attendees"</span>)]<br />        <span style="color: #0000ff">public</span> <span style="color: #0000ff">int</span> MinimumAttendees { get; set; }<br /> <br />        [Range(2, 100)]<br />        [Display(Name = <span style="color: #006080">"Maximum Attendees"</span>)]<br />        <span style="color: #0000ff">public</span> <span style="color: #0000ff">int</span> MaximumAttendees { get; set; }<br />    }<br />}</pre>

    <br /></div>

  <pre style="margin: auto; font-family: "> </pre>

  <p>This scenario also requires a <strong>Meeting.shared.cs</strong> file that defines a custom property on Meeting for <strong>IsLongMeeting</strong>.  We need to include this in a separate file, with the .shared.cs name convention so that the property is available on both the server and the client.</p>

  <div id="codeSnippetWrapper">
    <pre style="border-bottom-style: none; text-align: left; padding-bottom: 0px; line-height: 12pt; background-color: #f4f4f4; margin: 0em; border-left-style: none; padding-left: 0px; width: 100%; padding-right: 0px; font-family: 'Courier New', courier, monospace; direction: ltr; border-top-style: none; color: black; border-right-style: none; font-size: 8pt; overflow: visible; padding-top: 0px" id="codeSnippet"><span style="color: #0000ff">using</span> System;<br /> <br /><span style="color: #0000ff">namespace</span> RudeValidation.Web.Models<br />{<br />    <span style="color: #0000ff">public</span> <span style="color: #0000ff">partial</span> <span style="color: #0000ff">class</span> Meeting<br />    {<br />        <span style="color: #0000ff">public</span> <span style="color: #0000ff">bool</span> IsLongMeeting<br />        {<br />            get { <span style="color: #0000ff">return</span> <span style="color: #0000ff">this</span>.End.Subtract(<span style="color: #0000ff">this</span>.Start) &gt; <span style="color: #0000ff">new</span> TimeSpan(1, 0, 0); }<br />        }<br />    }<br />}</pre>

    <br /></div>

  <p> </p>

  <h3>Executing Derived Validation Attributes on the Client</h3>

  <p>Just as we saw with our custom validation methods, we can easily share custom reusable validation attributes by naming the files .shared.cs <em>(VB: .shared.vb)</em>.  Ultimately, RIA Services needs to be able to find the attribute type in Silverlight and be able to construct it from the instance discovered in your Web project, so it can also be achieved through class libraries in more advanced scenarios. </p>

  <p>Here’s what we get in the UI with these new validators, by simply editing the form values:</p>

  <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="Start cannot be in the past" border="0" alt="Start cannot be in the past" src="http://jeffhandley.com/images/jeffhandley_com/WindowsLiveWriter/RIAServicesValidation_14EEB/image%5B3%5D_d91359ca-7911-4f40-96cd-bd493555208a.png" width="480" height="96" /></p>

  <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="If you're asking for more than an hour of time, provide an agenda." border="0" alt="If you're asking for more than an hour of time, provide an agenda." src="http://jeffhandley.com/images/jeffhandley_com/WindowsLiveWriter/RIAServicesValidation_14EEB/image_32f034f8-46c0-48e2-974f-ad47b55dba14.png" width="556" height="311" /></p>

  <p><em>Notice that all three fields light up with the single error.  Editing any of the three fields will make the errors clear from all three fields.</em></p>

  <p> </p>

  <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="No one can ever find this room; please be sure to include directions." border="0" alt="No one can ever find this room; please be sure to include directions." src="http://jeffhandley.com/images/jeffhandley_com/WindowsLiveWriter/RIAServicesValidation_14EEB/image_2a74cfd7-325f-4782-9e74-7151f4ca10bb.png" width="563" height="235" /></p>

  <p><em>And the same is true here; both Location and Details light up when the hard-to-find room is entered but no details are entered.</em></p>

  <p> </p>

  <p><img style="background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="All errors cleared" border="0" alt="All errors cleared" src="http://jeffhandley.com/images/jeffhandley_com/WindowsLiveWriter/RIAServicesValidation_14EEB/image_50d5155c-f82a-4d38-b7a9-88dd7e6466dd.png" width="349" height="243" /></p>

  <p><em>Once Details are entered, all of the errors are cleared.</em></p>

  <h3>RIA Services Validation Recap:</h3>

  <p>In this post, we learned how to derive from ValidationAttribute to create custom, reusable validators.  Let’s take a look at related posts:</p>

  <ol>
    <ol>
      <li><a title="RIA Services Validation: Standard Validators" href="http://jeffhandley.com/archive/2010/09/22/RiaServicesStandardValidators.aspx">Standard Validators</a> </li>

      <li><a title="RIA Services Validation: Custom Validation Methods" href="/archive/2010/09/25/RiaServicesCustomValidationMethods.aspx">Custom Validation Methods</a> </li>

      <li><a title="RIA Services Validation: Custom Reusable Validators" href="/archive/2010/09/26/RiaServicesCustomReusableValidators.aspx" target="_blank">Custom Reusable Validators</a> </li>

      <li><a title="RIA Services Validation: Attribute Propagation" href="/archive/2010/09/30/RiaServicesValidationAttributePropagation.aspx">Attribute Propagation</a> </li>

      <li><a href="/archive/2010/10/06/RiaServicesValidationTriggers.aspx">Validation Triggers</a> </li>

      <li><a title="RIA Services Validation: Cross-Field Validation" href="/archive/2010/10/10/CrossFieldValidation.aspx">Cross-Field Validation</a> </li>

      <li><a title="RIA Services Validation: Entity-Level Validation" href="/archive/2010/10/12/EntityLevelValidation.aspx">Entity-Level Validation</a> </li>

      <li><a title="RIA Services Validation: Providing ValidationContext" href="/archive/2010/10/25/RiaServicesValidationContext.aspx">Providing ValidationContext</a> </li>

      <li><a title="RIA Services Validation: Using ValidationContext (Cross-Entity Validation)" href="/archive/2010/10/25/CrossEntityValidation.aspx">Using ValidationContext (Cross-Entity Validation)</a> </li>

      <li><a title="RIA Services Validation: ViewModel Validation with Entity Rules" href="http://jeffhandley.com/archive/2011/09/06/ViewModelValidation.aspx">ViewModel Validation with Entity Rules</a> </li>
    </ol>
  </ol>

  <p><strong><em>[9/6/2011] The source code for everything shown during the series is <a title="RIA Services Validation: Available on GitHub" href="http://jeffhandley.com/archive/2011/09/06/RIA-Services-Validation-Available-on-GitHub.aspx">available on GitHub</a>.</em></strong></p>

  <h3>Digging Deeper</h3>

  <p>Don’t worry, we are just getting started!  There are a plethora of topics to discuss for RIA Services validation.  In future posts, we’ll be exploring how RIA Services actually propagates your validators to the client, when/how RIA Services will invoke each kind of validator, how to really leverage ValidationContext, and much more.</p>

  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:0767317B-992E-4b12-91E0-4F059A8CECA8:debe4f4a-9b1b-46cd-9bc8-7d38a648092b" class="wlWriterEditableSmartContent">Technorati Tags: <a href="http://technorati.com/tags/RiaServicesValidation" rel="tag">RiaServicesValidation</a>,<a href="http://technorati.com/tags/RiaServices" rel="tag">RiaServices</a>,<a href="http://technorati.com/tags/Validation" rel="tag">Validation</a>,<a href="http://technorati.com/tags/Silverlight" rel="tag">Silverlight</a>,<a href="http://technorati.com/tags/DataAnnotations" rel="tag">DataAnnotations</a></div>

