---
layout: post
title: "Silverlight Airlines with a ViewModel"
date: 2008-11-14 22:22:45 -0800
comments: true
tags: ["Silverlight", "ViewModel"]
redirect_from: ["/archive/2008/11/14/silverlight-airlines-with-a-viewmodel.aspx/"]
author: "Jeff Handley"
---
<!-- more -->
<p>Not long after I joined Microsoft, I was looking at the <a href="http://blogs.msdn.com/delay/archive/2008/11/13/shamelessly-benefitting-from-the-work-of-others-links-to-silverlight-airlines-and-surface-samples-for-rtw.aspx" target="_blank">Silverlight Airlines</a> code sample.  I was new to Silverlight, so I used this demo as a way to help learn Silverlight.  The demo app is pretty cool, and ScottGu showed it off at Mix, so I had seen it before.  I took on an exercise to attempt to add some features to the application, and this helped me learn more about Silverlight.</p>  <p><img src="http://jeffhandley.com/Files/SilverlightAirlines.png" /> </p>  <p>To select a flight, you drag your mouse from one city to another, and then drag over the date range for your travel.  This will show a list of possible flights between the 2 cities.  You can hover over a flight and it will animate.  You can also click on a flight to “lock it in.”</p>  <p>There were 4 features that I wanted to add to this application:</p>  <ol>   <li>Allow a Return Flight to also be picked.  Right now, the date range you select is a bit useless; only the start date is used.  I wanted to use the end date for selecting a return flight. </li>  <li>Allow a Forms based view over this data. </li>  <li>Allow for business-logic driven boundaries on date selection. </li>  <li>Demonstrate how the stock calendar control could be dropped in and still have the application work – this would prove that the calendar control was decoupled from the rest of the application. </li> </ol>  <p>When I dove into the code to try to make this happen, I found that the code was a bit tangled up.  The main XAML page has 3 controls on it: Map, Calendar, ItineraryPicker.  These controls all know about each other and communicate with each other.  For instance, when cities are connected on the map, it informs the itinerary picker of the new cities.  When an itinerary is selected on the itinerary picker, it tells the map what to animate.  When dates are selected on the calendar, it tells the itinerary to get a new list of flights, which then tells the map to stop animating.</p>  <p>In order to support the return flight selection, I would have to be hacking away at the code in some not-so-pretty ways.  And I couldn’t see any way to offer a forms view.  The code needed to be refactored.  Into a ViewModel pattern.</p>  <p>You can see my version of the demo <a title="Silverlight Airlines - Using a ViewModel and with 2 new Features" href="http://jeffhandley.com/Files/SilverlightAirlines.Web/default.html" target="_blank">here</a>.  And you can download the code <a title="SilverlightAirlines.ViewModel.zip" href="http://jeffhandley.com/Files/SilverlightAirlines.ViewModel.zip">here</a>.  Set the web project to be your startup project before you run it.</p>  <p>If you look at the FlightSelectionMapView.xaml, you’ll see that there’s a lot more markup now.  However, this markup sets up the bindings to the ViewModel.  Here’s how it works:</p>  <ul>   <li>App.xaml.cs instantiates the FlightSelectionViewModel </li>  <li>This ViewModel instance is set as the DataContext of a container control that contains both the FlightSelectionMapView and the FlightSelectionFormView </li>  <li>The FlightSelectionViewModel has the following properties  <ul>   <li>City[] Cities </li>  <li>City Origin </li>  <li>City Destination </li>  <li>Itinerary[] DepartingItineraries </li>  <li>Itinerary[] ReturningItineraries </li>  <li>Itinerary SelectedDepartingItinerary </li>  <li>Itinerary SelectedReturningItinerary </li>  <li>DateTime AvailableDateStart </li>  <li>DateTime AvailableDateEnd </li>  <li>Collection&lt;DateTime&gt; TravelDates </li>  <li>DateTime? DepartingDate </li>  <li>DateTime? ReturningDate </li>   </ul>   </li>  <li>The Map control has bindings to the following properties:  <ul>   <li>Cities (one-way) </li>  <li>Origin (two-way) </li>  <li>Destination (two-way) </li>  <li>SelectedDepartingItinerary (one-way) </li>  <li>SelectedReturningItinerary (one-way) </li>   </ul>   </li>  <li>The Calendar control has been bound to the following properties:  <ul>   <li>SelectionStartDate (one-way) </li>  <li>SelectionEndDate (one-way) </li>  <li>TravelDates (two-way) </li>   </ul>   </li>  <li>The departing flight ItinerarySelector control then has the following bindings:  <ul>   <li>DepartingItineraries (one-way) </li>  <li>SelectedDepartingItinerary (two-way) </li>   </ul>   </li>  <li>And the returning light ItinerarySelector control has these bindings:  <ul>   <li>ReturningItineraries (one-way) </li>  <li>SelectedReturningItinerary (two-way) </li>   </ul>   </li> </ul>  <p>Note that there’s only one ItinerarySelector control, it’s just being used twice on the same form, once bound to the departing properties and once bound to the returning properties.</p>  <p>By refactoring the controls to work with these bound values, I was able to remove all references to the FlightService from the controls themselves.  Only the ViewModel references the FlightService.</p>  <p>A by-product of this achievement is that we can now unit test the ViewModel to ensure that the view interacts with the flight service correctly.  In the code download, you’ll notice that I have added a test project to demonstrate this.  It has some tests for the ViewModel, the FlightService, and the Itinerary class.</p>  <p>For the form view, I didn’t go too far with it.  I basically just proved that it could work.  It’s really, really ugly, and there are a couple of bugs.  But, there’s a button to switch to form view nonetheless.  You can make selections on the form and switch back to map view, and you see that the map view has changed to reflect the data you modified in form view.  This works because both views are sharing the same instance of the ViewModel, and they are both bound to its properties.</p>  <p>This shows how an existing application can be refactored into a ViewModel pattern to loosen up the coupling, offer better flexibility for new features, and also testability.  There are some different techniques that could be used on the ViewModel, but the goals were met for the exercises I set out to accomplish.</p>  <p><a title="SilverlightAirlines.ViewModel.zip" href="http://jeffhandley.com/Files/SilverlightAirlines.ViewModel.zip">Dig in</a> and <a title="Silverlight Airlines - Using a ViewModel and with 2 new Features" href="http://jeffhandley.com/Files/SilverlightAirlines.Web/default.html" target="_blank">enjoy</a>.  As always, I welcome all questions and feedback.  But be somewhat gentle – I wrote this code like 6 months ago, as part of learning Silverlight and the ViewModel pattern.</p>

