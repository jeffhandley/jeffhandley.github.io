---
layout: post
title: "RIA Services Validation: Validation Triggers"
date: 2010-10-06 10:48:19 -0700
comments: true
tags: ["RiaServicesValidation", "RiaServices", "Validation", "Silverlight", "DataAnnotations"]
redirect_from: ["/archive/2010/10/06/RiaServicesValidationTriggers.aspx/", "/archive/2010/10/06/riaservicesvalidationtriggers.aspx"]
author: "Jeff Handley"
---
<!-- more -->
<p>My goal with this blog post series is to provide an end-to-end tour of how RIA Services validation works and how you can leverage its capabilities to build rich, responsive applications.  A key factor for making the most of validation is fully understanding when and how RIA Services invokes your validation rules.  Awareness of the various validation triggers will help you implement your validators so they are fired as you expect, when you expect.  In this post will dig into the RIA Services codebase and identify every place where entity validation is invoked.</p>  <h3>Client-Side Validation</h3>  <h4>Property Setters – Events Raised</h4>  <p><a title="RIA Services Validation: Attribute Propagation" href="/archive/2010/09/30/RiaServicesValidationAttributePropagation.aspx" target="_blank"><img style="background-image: none; border-right-width: 0px; margin: 0px 0px 5px 10px; padding-left: 0px; padding-right: 0px; display: inline; float: right; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px" title="this.ValidateProperty" border="0" alt="this.ValidateProperty" align="right" src="http://jeffhandley.com/images/jeffhandley_com/Windows-Live-Writer/RIA-Services-Validation_147FF/image_dfa7b952-257c-4e18-9f4e-71f8b44195fb.png" width="384" height="339" /></a>As we saw in the <a title="RIA Services Validation: Attribute Propagation" href="/archive/2010/09/30/RiaServicesValidationAttributePropagation.aspx" target="_blank">Attribute Propagation</a> article, RIA Services injects validation logic within your entity property setters.  This comes in the form of a call to <strong>this.ValidateProperty(string propertyName, object value)</strong>.  The <a title="MSDN: Entity.ValidateProperty Method (String, Object)" href="http://msdn.microsoft.com/en-us/library/ff422361(VS.91).aspx" target="_blank">ValidateProperty</a> method is defined within the <a title="MSDN: Entity Class" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.client.entity(VS.91).aspx" target="_blank">Entity</a> base class that RIA Services uses for all of the generated entities.  This method has quite a bit of logic in it—let’s examine the flow:</p>  <ol>   <li>If the entity is currently being deserialized or merged (from a load or submit operation), then validation is bypassed entirely; </li>    <li>If the entity is read-only, an InvalidOperationException is thrown with the following message: “This entity is currently read-only. One of the following conditions exists: a domain method has been invoked, a submit operation is in progress, or edit operations are not supported for the entity Type.” </li>    <li>If the specified property has an <a title="MSDN: EditableAttribute Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.editableattribute(VS.95).aspx" target="_blank">[Editable]</a> attribute applied to it that indicates that the property cannot be edited, then an InvalidOperationException is thrown with the following message: “The {0} property is read only.” </li>    <li>If the specified property has any attributes that derive from <a title="MSDN: ValidationAttribute Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationattribute(VS.95).aspx" target="_blank">ValidationAttribute</a>, then validation proceeds. </li> </ol>  <p>When validation proceeds, the <strong>ValidateProperty(string propertyName, object value)</strong> method creates a <a title="MSDN: ValidationContext Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationcontext(VS.95).aspx" target="_blank">ValidationContext</a> with the <a title="MSDN: ValidationContext.MemberName Property" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationcontext.membername(VS.95).aspx" target="_blank">MemberName</a> specified as the property name being validated.  Then, another overload of ValidateProperty is called: <strong><a title="MSDN: Entity.ValidateProperty Method (ValidationContext, Object)" href="http://msdn.microsoft.com/en-us/library/ff422694(VS.91).aspx" target="_blank">ValidateProperty(ValidationContext validationContext, object value)</a></strong>.  This overload of ValidateProperty is virtual, which means you can override it in your Entity classes if you wish to change the core behavior of property setter validation.</p>  <p>The default implementation of <strong>ValidateProperty(ValidationContext validationContext, object value)</strong> uses the <a title="MSDN: Validator Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validator.aspx" target="_blank">Validator</a> static class within System.ComponentModel.DataAnnotations, calling its <a title="MSDN: Validator.TryValidateProperty Method" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validator.tryvalidateproperty.aspx" target="_blank">TryValidateProperty</a> method to accumulate validation errors for the property and the intended value.  The collected errors are then applied to the Entity’s <a title="MSDN: Entity.ValidationErrors Property" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.client.entity.validationerrors(VS.91).aspx" target="_blank">ValidationErrors</a> collection, which triggers <a title="MSDN: INotifyDataErrorInfo.ErrorsChanged Event" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.inotifydataerrorinfo.errorschanged(VS.95).aspx" target="_blank">ErrorsChanged</a> events for the <a title="MSDN: INotifyDataErrorInfo Interface" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.inotifydataerrorinfo(VS.95).aspx" target="_blank">INotifyDataErrorInfo</a> interface, as appropriate.  This informs the UI that errors have occurred, and the error messages are displayed automatically.</p>  <h5>Entity State During Property Validation</h5>  <p>There’s one very subtle detail that is important to point out related to the state of your entity when ValidateProperty is invoked.  If you look closely at the generated property setter code, you’ll see that the private field for <em>this._title</em> is not updated with the new value until <em>after</em> ValidateProperty has completed.  This might seem odd at first, but with a quick look at the matrix below, you’ll see why this decision was made.</p>  <table border="2" cellspacing="0" cellpadding="2" width="852"><tbody>     <tr>       <td valign="top" width="196">         <p align="center"><strong>Validator Requirement</strong></p>       </td>        <td valign="top" width="324">         <p align="center"><strong>Update Value <u>Before</u> Validation</strong></p>       </td>        <td valign="top" width="328">         <p align="center"><strong>Update Value <u>After</u> Validation</strong></p>       </td>     </tr>      <tr>       <td valign="top" width="196"><em>Access New Value</em></td>        <td valign="top" width="324">Use ‘value’ parameter <em>or</em> property getter</td>        <td valign="top" width="328">Use ‘value’ parameter</td>     </tr>      <tr>       <td valign="top" width="196"><em>Access Old Value</em></td>        <td valign="top" width="324"><font color="#ff0000">Unavailable</font></td>        <td valign="top" width="328">Use property getter</td>     </tr>      <tr>       <td valign="top" width="196"><em>Prevent Property Update</em></td>        <td valign="top" width="324"><font color="#ff0000">Unavailable</font></td>        <td valign="top" width="328">Throw ValidationException</td>     </tr>   </tbody></table>  <h5>Entity State After Property Validation</h5>  <p>Another subtle detail about property validation lies in the state of the entity after property validation occurs.  In the default implementation of ValidateProperty, events are raised when validation errors occur, but no exceptions are thrown.  This means the backing field for the property is updated immediately after validation is performed, and even when validation resulted in errors, the property value is updated to to new value.  Therefore, it is commonplace for your entities to have invalid property values.  <em>Note: This wasn’t always the case.  Before Silverlight 4 introduced INotifyDataErrorInfo, RIA Services would throw a ValidationException during validation, so in early preview releases of RIA Services, the behavior was different.</em></p>  <h4>Ending Edit Sessions – Events Raised</h4>  <p>The Entity base class implements an interface called <a title="MSDN: IEditableObject Interface" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.ieditableobject.aspx" target="_blank">IEditableObject</a>.  This interface defines behavior for allowing an object to have edit sessions applied to it, with the following members: BeginEdit, CancelEdit, and EndEdit.  When BeginEdit is called, an edit session begins and the state of the entity is recorded.  If CancelEdit is called to close the edit session, the entity is reverted to its state at the time BeginEdit was invoked, and validation does not occur.  If the edit session is closed by calling EndEdit, then the entity will validate itself against its new state.</p>  <p>An edit session typically involves updating property values, which will trigger property setter validation as described above.  But when an edit session is ended, the entity is given an opportunity to perform what is called “entity-level validation.”  We have seen examples of validation attributes applied to entity properties, but it’s also possible to apply validation attributes to an entity class itself.  Many times, there are no simple property-edit triggers to perform cross-field validation, so this logic can be applied on the entity class itself, and whenever an edit session for the entity is ended, these validators will be invoked.  <em>We will explore entity-level validators more in our next post!</em></p>  <p>During <a title="MSDN: Entity.EndEdit Method" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.client.entity.endedit(VS.91).aspx" target="_blank">EndEdit</a>, entity-level validators aren’t the only ones invoked though.  In fact, the following algorithm is used:</p>  <ol>   <li>Execute all <a title="MSDN: RequiredAttribute Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.requiredattribute.aspx" target="_blank">[Required]</a> validators on the entity’s properties.  If any required properties are missing values, validation fails and stops (but multiple required-field validation errors can occur). </li>    <li>Execute the remainder of the property-level validators.  If any property is found to be invalid, validation fails and stops (but multiple property validation errors can occur). </li>    <li>Execute all entity-level validators.  If any entity-level validator is found to be invalid, validation fails and stops (but multiple validation errors can occur). </li> </ol>  <p>Notice that validation stops if there are any required properties that haven’t been satisfied.  This is done so that all other validators can assume that any required value has been specified.  Similarly, if properties are found to be invalid, there’s no sense in executing entity-level validation—entity-level validators can assume that if they are being called, all properties are in a valid state.  If these blocks were not in place, you’d find yourself having to repeat property validation within your entity validation logic.</p>  <p>Once validation completes, the edit session will be committed and closed regardless of validation success.  <em>This is largely because the IEditableObject interface is ignorant of validation and it has no concept for TryEndEdit.</em>  Any validation errors that occur during EndEdit will be added to the entity’s ValidationErrors collection, and INotifyDataErrorInfo.ErrorsChanged events will be raised.  The UI then displays the validation errors to the end user.</p>  <h4>Submitting Changes – SubmitOperation Error</h4>  <p>After you have committed edits to your entities, the next step is to submit those changes to the server. This is done through the <a title="MSDN: DomainContext.SubmitChanges Method" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.client.domaincontext.submitchanges(VS.91).aspx" target="_blank">DomainContext.SubmitChanges</a> method.  This method will perform validation against all entities that have pending changes, ensuring that none of them is in an invalid state before submitting the changeset to the server.  The method will perform entity-level validation much like EndEdit did, with 3-stage validation.  Any entities that are found to have validation errors will have their ValidationErrors collections populated.  Additionally, if there were any validation errors, the <a title="MSDN: SubmitOperation Class" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.client.submitoperation(VS.91).aspx" target="_blank">SubmitOperation</a> will fail (without even going to the server), and the <a title="MSDN: SubmitOperation.EntitiesInError Property" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.client.submitoperation.entitiesinerror(VS.91).aspx" target="_blank">EntitiesInError</a> collection will contain all of the entities that had validation errors. </p>  <h4>Custom Update Methods – ValidationException Thrown</h4>  <p>In addition to standard CRUD operations, RIA Services supports custom update methods, where business logic can be encapsulated within a <a title="MSDN: DomainService Class" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.server.domainservice(VS.91).aspx" target="_blank">DomainService</a> method.  For example, a DomainService that exposes a Meeting entity would likely have Query, Insert, Update, and Delete methods for an Meeting, but it could also have a CancelMeeting method, which is a custom update method for the Meeting entity.  On the client, this method shows up as a CancelMeeting method on the Meeting entity itself, in addition to a CancelMeeting method on the DomainContext.  <em>The DomainContext method will simply call the CancelMeeting method on the entity specified, so both approaches have the same result.</em></p>  <p>If you are <a title="MSDN: UpdateAttribute.UsingCustomMethod Property" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.server.updateattribute.usingcustommethod(VS.91).aspx" target="_blank">using a custom update method</a>, and you invoke the method on the client, the entity will be validated using a routine similar to what we saw with EndEdit, but with one notable difference.  With EndEdit, validation failures were added to the ValidationErrors collection, but the operation still succeeded.  <font style="background-color: #ffff00"><strong>When invoking a custom update method on an entity, a validation failure will result in a ValidationException being thrown</strong>.</font>  This means that calls to these custom update methods should be wrapped in try/catch blocks that will catch any <a title="MSDN: ValidationException Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationexception.aspx" target="_blank">ValidationException</a> that occurs, informing the end user that the operation could not be completed.</p>  <h3>Server-Side Validation</h3>  <p>While RIA Services performs client-side validation every step of the way toward submitting data to the server, that’s simply not enough.  No client/server application should ever trust data that came from the client; validation must always be repeated on the server to ensure the data submitted by the client is in valid form.  Fortunately, RIA Services does this for you seamlessly and automatically.</p>  <h4>Submitting Changes – SubmitOperation Error</h4>  <p>When a DomainContext.SubmitChanges call from the client passes client-side validation, a changeset is submitted to your DomainService.  Before your insert, update, and delete methods are called, RIA Services will validate all entities included in the changeset.  Once again, the same 3-stage validation will be respected.  If any entities in the changeset are invalid, the submission is canceled and the validation errors are returned to the client.  This will result in a SubmitOperation error, and the EntitiesInError collection will be populated, and for each entity that had validation failures, the ValidationErrors collection will also be populated.  Whether the validation failures occurred on the client or on the server, the result is the same, allowing a consistent experience for both you and the end user.</p>  <h5>IValidatableObject</h5>  <p>Another feature available on the server is an interface called <a title="MSDN: IValidatableObject Interface" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.ivalidatableobject.aspx" target="_blank">IValidatableObject</a>.  This interface was added in .NET 4.0 for RIA Services.  This interface has a single member, a <strong>Validate()</strong> method that returns an <strong>IEnumerable&lt;ValidationResult&gt;</strong>.  This interface allows your server-side entities to encapsulate additional entity-level validation logic outside the validation attributes.  <strong>IValidatableObject.Validate()</strong> is actually called as a 4<sup>th</sup> stage of validation on the server, and it is only called if the first 3 stages of validation were successful.  Therefore, the server-side algorithm for validation is actually as follows:</p>  <ol>   <ol>     <li>Execute all [Required] validators on the entity’s properties.  If any required properties are missing values, validation fails and stops (but multiple required-field validation errors can occur). </li>      <li>Execute the remainder of the property-level validators.  If any property is found to be invalid, validation fails and stops (but multiple property validation errors can occur). </li>      <li>Execute all entity-level validators.  If any entity-level validator is found to be invalid, validation fails and stops (but multiple validation errors can occur). </li>      <li>Check the entity for an IValidatableObject implementation; if implemented, execute the Validate() method.  If any validation errors are returned, validation fails. </li>   </ol> </ol>  <h5>Server-Only Validation</h5>  <p>There are other benefits to having server-side validation occur during change submission beyond re-executing the same validators that existed on the client.  It’s quite common to have validation logic that can only be performed on the server.  Consider a scenario where validation involves querying a database—this cannot be done synchronously in Silverlight.  In this situation, a custom validation method or attribute can be applied to your entity, using a method or attribute that isn’t shared with the client.  These validators will be invoked on the server even though they were not propagated to the client.</p>  <h3>Additional Validation Triggers</h3>  <p>In addition to the validation that RIA Services invokes, the Silverlight SDK and Toolkit also have validation features integrated into UI controls.  I won’t be going into explicit detail on these controls, but it’s important to understand that these additional validation triggers exist and they result in your validation attributes being invoked repeatedly when using these UI controls.</p>  <h4>DataGrid</h4>  <p>In the Silverlight SDK, the <a title="MSDN: DataGrid Class" href="http://msdn.microsoft.com/en-us/library/system.windows.controls.datagrid(VS.95).aspx" target="_blank">DataGrid</a> control is validation-aware, and it performs validation aggressively.  As you begin editing a row, validation will occur to get the initial validation state of the entity.  Then, as you edit cell values, the properties will be validated.  And lastly, when you attempt to commit a row, the entity will be validated once more.  You will notice that your validation attributes get invoked many times during this process, since the DataGrid cannot assume the entity is self-validating, and the entity cannot assume the UI is performing validation either.</p>  <h4>DataForm</h4>  <p>In the Silverlight Toolkit, the DataForm control is validation-aware, and it too performs validation pessimistically, although not quite as aggressively as DataGrid.  DataForm will ensure that all properties’ values have been validated against the currently-displayed form values when the end user attempts to commit an edit session.  This involves an iteration over all form fields, forcing the currently-displayed values to be passed to the property setters again.  Additionally, DataForm will perform full object validation before allowing the current item selection to change.</p>  <p><em>Note: The RIA Services ‘Business Application Project’ template includes a copy of the DataForm control as well.  This is shipped as a standalone assembly within the project template, but the assembly comes from the Silverlight Toolkit.</em></p>  <h3>RIA Services Validation Recap</h3>  <p>This post is part of a series dedicated to RIA Services Validation.  We have now learned about all of the code paths in RIA Services that execute entity validation.  You now know when to expect your validation logic to get invoked, and in what various states validation can occur.  I am hopeful that this knowledge will allow you to provide richer experiences for your users.</p>  <p>Here’s a look at the posts in this series:</p>  <ol>   <ol>     <li><a title="RIA Services Validation: Standard Validators" href="http://jeffhandley.com/archive/2010/09/22/RiaServicesStandardValidators.aspx">Standard Validators</a> </li>      <li><a title="RIA Services Validation: Custom Validation Methods" href="/archive/2010/09/25/RiaServicesCustomValidationMethods.aspx">Custom Validation Methods</a> </li>      <li><a title="RIA Services Validation: Custom Reusable Validators" href="/archive/2010/09/26/RiaServicesCustomReusableValidators.aspx" target="_blank">Custom Reusable Validators</a> </li>      <li><a title="RIA Services Validation: Attribute Propagation" href="/archive/2010/09/30/RiaServicesValidationAttributePropagation.aspx">Attribute Propagation</a> </li>      <li><a href="/archive/2010/10/06/RiaServicesValidationTriggers.aspx">Validation Triggers</a> </li>      <li><a title="RIA Services Validation: Cross-Field Validation" href="/archive/2010/10/10/CrossFieldValidation.aspx">Cross-Field Validation</a> </li>      <li><a title="RIA Services Validation: Entity-Level Validation" href="/archive/2010/10/12/EntityLevelValidation.aspx">Entity-Level Validation</a> </li>      <li><a title="RIA Services Validation: Providing ValidationContext" href="/archive/2010/10/25/RiaServicesValidationContext.aspx">Providing ValidationContext</a> </li>      <li><a title="RIA Services Validation: Using ValidationContext (Cross-Entity Validation)" href="/archive/2010/10/25/CrossEntityValidation.aspx">Using ValidationContext (Cross-Entity Validation)</a> </li>      <li><a title="RIA Services Validation: ViewModel Validation with Entity Rules" href="http://jeffhandley.com/archive/2011/09/06/ViewModelValidation.aspx">ViewModel Validation with Entity Rules</a> </li>   </ol> </ol>  <p><strong><em>[9/6/2011] The source code for everything shown during the series is <a title="RIA Services Validation: Available on GitHub" href="http://jeffhandley.com/archive/2011/09/06/RIA-Services-Validation-Available-on-GitHub.aspx">available on GitHub</a>.</em></strong></p>  <h3>Digging Deeper</h3>  <p>We have now exposed all of the details for how your entity validation logic is propagated to the client and when it is executed.  Now, we can return to more examples of how to implement validation logic within your application.  We learned in this post that validation isn’t limited to properties and that you can create entity-level validators; in the next post, we’ll explore entity-level validation and illustrate some cross-field validation scenarios and approaches.  Beyond that, we will learn more about ValidationContext and ViewModel validation.</p>  <div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:0767317B-992E-4b12-91E0-4F059A8CECA8:4a90164a-252e-4164-8670-f231f2550d1d" class="wlWriterEditableSmartContent">Technorati Tags: <a href="http://technorati.com/tags/RiaServicesValidation" rel="tag">RiaServicesValidation</a>,<a href="http://technorati.com/tags/RiaServices" rel="tag">RiaServices</a>,<a href="http://technorati.com/tags/Validation" rel="tag">Validation</a>,<a href="http://technorati.com/tags/Silverlight" rel="tag">Silverlight</a>,<a href="http://technorati.com/tags/DataAnnotations" rel="tag">DataAnnotations</a></div>

