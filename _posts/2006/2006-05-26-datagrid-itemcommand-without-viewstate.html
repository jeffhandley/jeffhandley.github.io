---
layout: post
title: DataGrid ItemCommand Without ViewState
date: '2006-05-26T03:37:00.000-07:00'
author: Jeff Handley
tags: 
modified_time: '2006-05-26T14:31:34.416-07:00'
blogger_id: tag:blogger.com,1999:blog-10056400.post-114864018714432559
blogger_orig_url: http://jeffhandley.blogspot.com/2006/05/datagrid-itemcommand-without-viewstate.html
---

I <a href="http://jeffhandley.blogspot.com/2006/03/datagrid-viewstate.html" target="_blank">blogged awhile back</a> about my frustrations with the ASP.NET DataGrid and its reliance on ViewState, specifically for firing the ItemCommand event. Well this situation presented itself to me again and I decided to attack the problem with a little more aggression than previous attempts.<br /><br />It's important to note that with my concept of <a href="http://jeffhandley.blogspot.com/2005/05/custom-web-controls-everywhere.html" target="_blank"> Custom Web Controls Everywhere</a>, I was able to implement an application-wide solution pretty easily. I will outline the solution here, but without some custom controls already in place, this concept cannot be easily applied.<br /><br />Let’s start by discussing why ItemCommand events don’t fire within the DataGrid when ViewState is turned off. There are a couple of causes for this. First, with ViewState turned off, when the postback fires, the DataGrid does not have any items anymore. With no items, there are no controls to look at to identify that the event source was an item within the DataGrid. Second, the CommandName and CommandArgument that were set on the control are not persisted anywhere outside of ViewState. So even if the system was able to identify that the event source was within the DataGrid, there’s no CommandName or CommandArgument to use for firing the command.<br /><br />So, how do we solve these two problems?<br /><br />The typical recommendation seems to be to bind the DataGrid again, so that the control hierarchy can be rebuilt and the CommandName and CommandArgument can be restored. But this has severe drawbacks in my opinion. First, you’re forced to hit the database again, and depending on the system and the function, this might be a big deal. Second, and probably more importantly, the data may change between calls, altering the control hierarchy. This could potentially line the control ID from the event up with an entirely different record. Imagine you’re firing a Delete command, and you will now go delete the selected record without confirmation. You may be deleting the incorrect record – oops! Because of these 2 issues, I’ve never thought re-binding was an acceptable solution.<br /><br />Unfortunately though, I don’t have an answer to the first problem of losing the control references. The controls are gone, but maybe we don’t care… let’s look at how we solve the second problem. I’m actually using a trick that I used a few years ago for <a href="http://www.statsworld.com/" target="statsworld">http://www.statsworld.com</a>. There were many screens in that site that were going to show very large amounts of data, in a grid format. These screens needed to be ultra-high performance, so I didn’t even attempt to use the DataGrid. Instead, I created what we called at the time the SuperGrid. The SuperGrid did lots of great things, including having the ability to drill down into records without ViewState being turned on. But the SuperGrid was an extremely specialized solution that won’t ever get reused outside of Statsworld. But I came up with a key principle that I’m reapplying now. And that is to persist the CommandName and CommandArgument into the JavaScript __doPostBack call.<br /><br />What I find ironic about this is that from what I recall, in ASP.NET 1.0 Beta 1, the CommandArgument was persisted into the JavaScript __doPostBack call for us. But with ASP.NET 1.0 Beta 2, it was no longer persisted. I’m not sure I’ve ever found what the __EVENTARGUMENT is used for anymore, but it’s going to come in handy here for us.<br /><br />Now, in order to get the CommandName and CommandArgument persisted into the JavaScript, we have some hoops we need to jump through. But with a custom DataGrid in place, we only have to do this in one place. Aren’t you glad that you created a custom DataGrid even though you weren’t sure what all you would use it for? Let’s break it down...<br /><br />First, let’s start with an inherited DataGrid class, nothing special here except that we’re declaring constants for __EVENTTARGET and __EVENTARGUMENT which will get used later. We also went ahead and wired up the Load and PreRender events.<br /><br /><pre class="csharpcode"><span class="kwrd">using</span> System;<br /><br /><span class="kwrd">namespace</span> Controls<br />{<br />  <span class="rem">/// &lt;summary&gt;</span><br />  <span class="rem">/// Inherit the ASP.NET DataGrid</span><br />  <span class="rem">/// &lt;/summary&gt;</span><br />  <span class="kwrd">public</span> <span class="kwrd">class</span> DataGrid : System.Web.UI.WebControls.DataGrid<br />  {<br />    <span class="rem">// Use these to get data from the forms collection</span><br />    <span class="kwrd">private</span> <span class="kwrd">const</span> <span class="kwrd">string</span> _EventTarget = <span class="str">"__EVENTTARGET"</span>;<br />    <span class="kwrd">private</span> <span class="kwrd">const</span> <span class="kwrd">string</span> _EventArgument = <span class="str">"__EVENTARGUMENT"</span>;<br /><br />    <span class="rem">/// &lt;summary&gt;</span><br />    <span class="rem">/// Constuctor for the custom data grid</span><br />    <span class="rem">/// &lt;/summary&gt;</span><br />    <span class="kwrd">public</span> DataGrid()<br />    {<br />      <span class="rem">// Wire up the Load &amp; PreRender event handlers</span><br />      <span class="kwrd">this</span>.Load += <span class="kwrd">new</span> EventHandler(DataGrid_Load);<br />      <span class="kwrd">this</span>.PreRender += <span class="kwrd">new</span> EventHandler(DataGrid_PreRender);<br />    }<br />  }<br />}<br /></pre><br />Now we need to handle the PreRender event within the DataGrid.  This is where we’ll check to see if ViewState is being used and if not, we’ll start the ball rolling.<br /><br /><pre class="csharpcode"><span class="rem">/// &lt;summary&gt;</span><br /><span class="rem">/// PreRender event handler</span><br /><span class="rem">/// &lt;/summary&gt;</span><br /><span class="rem">/// &lt;param name="sender"&gt;&lt;/param&gt;</span><br /><span class="rem">/// &lt;param name="e"&gt;&lt;/param&gt;</span><br /><span class="kwrd">private</span> <span class="kwrd">void</span> DataGrid_PreRender(<span class="kwrd">object</span> sender, EventArgs e)<br />{<br />    <span class="rem">// If viewstate is turned off, then we need to persist any</span><br />    <span class="rem">// commands inside the grid</span><br />    <span class="rem">// We need to look all the way up to the page to make</span><br />  <span class="rem">// sure that we don't have a parent with viewstate</span><br />  <span class="rem">// turned off even though ours is turned on</span><br />    <span class="kwrd">if</span> (!IsUsingViewState())<br />        PersistCommands(<span class="kwrd">this</span>);<br />}<br /><br /><span class="rem">/// &lt;summary&gt;</span><br /><span class="rem">/// Determine if we get to use viewstate</span><br /><span class="rem">/// &lt;/summary&gt;</span><br /><span class="kwrd">private</span> <span class="kwrd">bool</span> IsUsingViewState()<br />{<br />    System.Web.UI.Control Control = <span class="kwrd">this</span>;<br /><br />    <span class="rem">// We need to look all the way up to the page to make</span><br />  <span class="rem">// sure that we don't have a parent with viewstate</span><br />  <span class="rem">// turned off even though ours is turned on</span><br />    <span class="kwrd">while</span> (Control != <span class="kwrd">null</span> &amp;&amp; Control.EnableViewState)<br />        Control = Control.Parent;<br /><br />  <span class="kwrd">bool</span> UsingViewState = <span class="kwrd">true</span>;<br /><br />    <span class="rem">// If we found a parent with viewstate turned off, we</span><br />  <span class="rem">// have stopped searching and we need to persist any</span><br />  <span class="rem">// commands inside ourself</span><br />    <span class="kwrd">if</span> (Control != <span class="kwrd">null</span> &amp;&amp; !Control.EnableViewState)<br />        UsingViewState = <span class="kwrd">false</span>;<br /><br />  <span class="rem">// Let's store a flag in viewstate.  This allows us to know</span><br />  <span class="rem">// for sure whether we rendered with viewstate or not.</span><br />  <span class="kwrd">this</span>.ViewState[<span class="str">"DataGrid.IsUsingViewState"</span>] = UsingViewState;<br /><br />    <span class="kwrd">return</span> UsingViewState;<br />}<br /><br /><span class="rem">/// &lt;summary&gt;</span><br /><span class="rem">/// Check to see if we were using viewstate on the</span><br /><span class="rem">/// previous render</span><br /><span class="rem">/// &lt;/summary&gt;</span><br /><span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span><br /><span class="kwrd">private</span> <span class="kwrd">bool</span> WasUsingViewState()<br />{<br />  <span class="rem">// If we don't have the flag in viewstate, then we can assume</span><br />  <span class="rem">// that we don't have viewstate</span><br />  <span class="kwrd">if</span> (<span class="kwrd">this</span>.ViewState[<span class="str">"DataGrid.IsUsingViewState"</span>] == <span class="kwrd">null</span>)<br />    <span class="kwrd">return</span> <span class="kwrd">false</span>;<br />  <span class="kwrd">else</span><br />    <span class="kwrd">return</span> Convert.ToBoolean(<br />      <span class="kwrd">this</span>.ViewState[<span class="str">"DataGrid.IsUsingViewState"</span>]);<br />}<br /></pre><br />Inside PreRender, we use the IsUsingViewState function and search up the control hierarchy to see if ViewState is turned off anywhere.  If so, we call a method to persist any commands inside ourself.  This is where the fun begins.<br /><br /><pre class="csharpcode"><span class="rem">/// &lt;summary&gt;</span><br /><span class="rem">/// Persist any commands inside LinkButtons -- Recursive method</span><br /><span class="rem">/// &lt;/summary&gt;</span><br /><span class="rem">/// &lt;param name="Parent"&gt;&lt;/param&gt;</span><br /><span class="kwrd">private</span> <span class="kwrd">void</span> PersistCommands(System.Web.UI.Control Parent)<br />{<br />  <span class="kwrd">bool</span> LinkButtonFound = <span class="kwrd">false</span>;<br /><br />  <span class="rem">// Search all child controls for LinkButtons</span><br />  <span class="kwrd">foreach</span> (System.Web.UI.Control Child <span class="kwrd">in</span> Parent.Controls)<br />  {<br />    <span class="kwrd">if</span> (!LinkButtonFound<br />      &amp;&amp; Child <span class="kwrd">is</span> System.Web.UI.WebControls.LinkButton)<br />    {<br />      <span class="rem">// We found a LinkButton, let's take over the</span><br />      <span class="rem">// rendering of the LinkButton's parent.  We have</span><br />      <span class="rem">// to take over rendering at the parent level</span><br />      <span class="rem">// because the RenderMethod is only called when</span><br />      <span class="rem">// the control has its own children.  We can't</span><br />      <span class="rem">// assume that the LinkButton will have children,</span><br />      <span class="rem">// but we know that the LinkButton is a child of</span><br />      <span class="rem">// its parent.  So we can safely take over rendering</span><br />      <span class="rem">// of the current Parent.</span><br />      System.Web.UI.WebControls.LinkButton Link = <br />        (System.Web.UI.WebControls.LinkButton)Child;<br /><br />      Parent.SetRenderMethodDelegate(<br />        <span class="kwrd">new</span> System.Web.UI.RenderMethod(<br />          LinkButtonParentRenderer));<br /><br />      <span class="rem">// We don't need to check any more controls within</span><br />      <span class="rem">// this parent, because the parent is already set</span><br />      <span class="rem">// to use the custom renderer</span><br />      LinkButtonFound = <span class="kwrd">true</span>;<br />    }<br /><br />    <span class="rem">// Process any grandchild controls -- recursive call</span><br />    PersistCommands(Child);<br />  }<br />}<br /></pre><br />The magic trick here is using the <a href="http://msdn2.microsoft.com/en-us/library/system.web.ui.control.setrendermethoddelegate.aspx" target="MSDN">SetRenderMethodDelegate</a> property on the LinkButton’s parent control – the parent control – not the LinkButton itself. SetRenderMethodDelegate is documented as, “Assigns an event handler delegate to render the server control and its content into its parent control.” Using <a href="http://www.aisto.com/roeder/dotnet/" target="reflector">.NET Reflector</a>, we can see that System.Web.UI.Control.RenderChildren is defined as the following:<br /><br /><pre class="csharpcode" style="background-color:#FFFF99"><span class="kwrd">protected</span> <span class="kwrd">virtual</span> <span class="kwrd">void</span> RenderChildren(HtmlTextWriter writer)<br />{<br />  <span class="kwrd">if</span> (<span class="kwrd">this</span>._renderMethod != <span class="kwrd">null</span>)<br />  {<br />    <span class="kwrd">this</span>._renderMethod(writer, <span class="kwrd">this</span>);<br />  }<br />  <span class="kwrd">else</span> <span class="kwrd">if</span> (<span class="kwrd">this</span>._controls != <span class="kwrd">null</span>)<br />  {<br />    <span class="kwrd">int</span> num1 = <span class="kwrd">this</span>._controls.Count;<br />    <span class="kwrd">for</span> (<span class="kwrd">int</span> num2 = 0; num2 &lt; num1; num2++)<br />    {<br />      <span class="kwrd">this</span>._controls[num2].RenderControl(writer);<br />    }<br />  }<br />}<br /></pre><br />So, when there is a render method defined for a control, that method is called in place of the standard RenderControl.  This lets us hijack the rendering of any control.  Now we are doing this for any control that contains a LinkButton.<br /><br />So what do we do with the LinkButtonParentRenderer?  Let’s dig in!<br /><br /><pre class="csharpcode"><span class="rem">/// &lt;summary&gt;</span><br /><span class="rem">/// This is our custom renderer for link button parents</span><br /><span class="rem">/// &lt;/summary&gt;</span><br /><span class="rem">/// &lt;param name="writer"&gt;&lt;/param&gt;</span><br /><span class="rem">/// &lt;param name="Parent"&gt;&lt;/param&gt;</span><br /><span class="kwrd">private</span> <span class="kwrd">void</span> LinkButtonParentRenderer(<br />  System.Web.UI.HtmlTextWriter writer,<br />  System.Web.UI.Control Parent)<br />{<br />  <span class="rem">// Loop through all of the controls in the Parent.</span><br />  <span class="rem">// We know that we'll hit at least one LinkButton</span><br />  <span class="kwrd">foreach</span> (System.Web.UI.Control Child <span class="kwrd">in</span> Parent.Controls)<br />  {<br />    <span class="rem">// Is this our LinkButton?</span><br />    <span class="kwrd">if</span> (Child <span class="kwrd">is</span> System.Web.UI.WebControls.LinkButton)<br />    {<br />      <span class="rem">// We found a LinkButton.  We need to override</span><br />      <span class="rem">// his rendering so that we can set up a custom</span><br />      <span class="rem">// Href attribute, overriding what the LinkButton</span><br />      <span class="rem">// would have done by default</span><br />      System.Web.UI.WebControls.LinkButton Link = <br />        (System.Web.UI.WebControls.LinkButton)Child;<br /><br />      <span class="rem">// Get the custom PostBack Link to use on the tag</span><br />      <span class="rem">// and add it as the Href attribute</span><br />      writer.AddAttribute(<br />        System.Web.UI.HtmlTextWriterAttribute.Href,<br />        GetPostBackLink(Link));<br /><br />      <span class="rem">// Call the LinkButton's RenderBeginTag routine</span><br />      <span class="rem">// to open his tag</span><br />      Link.RenderBeginTag(writer);<br />  <br />      <span class="rem">// If the LinkButton has controls, we need to render</span><br />      <span class="rem">// them.  From: System.Web.UI.Control.RenderChildren</span><br />      <span class="kwrd">if</span> (Link.HasControls())<br />      {<br />        <span class="rem">// Make sure the controls collection exists</span><br />        <span class="kwrd">if</span> (Link.Controls != <span class="kwrd">null</span>)<br />        {<br />          <span class="rem">// Render each child control</span><br />          <span class="kwrd">foreach</span> (System.Web.UI.Control LinkChild<br />                      <span class="kwrd">in</span> Link.Controls)<br />          {<br />            LinkChild.RenderControl(writer);<br />          }<br />        }<br />      }<br />      <span class="kwrd">else</span><br />      {<br />        <span class="rem">// The LinkButton didn't have any child controls,</span><br />        <span class="rem">// so just render his text</span><br />        writer.Write(Link.Text);<br />      }<br /><br />      <span class="rem">// Close the tag</span><br />      Link.RenderEndTag(writer);<br />    }<br />    <span class="kwrd">else</span><br />    {<br />      <span class="rem">// This wasn't a LinkButton, so just</span><br />      <span class="rem">// render him normally</span><br />      Child.RenderControl(writer);<br />    }<br />  }<br />}<br /></pre><br />The important part is that for any LinkButtons, we call writer.AddAttribute to assign the Href attribute, and then we call RenderBeginTag.  This opens the &lt;a&gt; tag with our custom Href attribute.  From there, we render the contents of the LinkButton.  Thank goodness for <a href="http://www.aisto.com/roeder/dotnet/" target="reflector">.NET Reflector</a>!<br /><br />Our custom routine for GetPostBackLink is pretty simple, but this is where we actually persist the CommandName and CommandArgument into the JavaScript.<br /><br /><pre class="csharpcode"><span class="rem">/// &lt;summary&gt;</span><br /><span class="rem">/// Get a modified PostBack client hyperlink with the</span><br /><span class="rem">/// command name and the command argument embedded</span><br /><span class="rem">/// &lt;/summary&gt;</span><br /><span class="rem">/// &lt;param name="Link"&gt;&lt;/param&gt;</span><br /><span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span><br /><span class="kwrd">private</span> <span class="kwrd">string</span> GetPostBackLink(<br />  System.Web.UI.WebControls.LinkButton Link)<br />{<br />  <span class="rem">// Get a standard postback hyperlink</span><br />  <span class="kwrd">string</span> PostBack = <span class="kwrd">this</span>.Page.GetPostBackClientHyperlink(Link,<br />    Link.CommandArgument);<br /><br />  <span class="rem">// Mimic Control.UniqueIDWithDollars so that we can</span><br />  <span class="rem">// manipulate the EventTarget portion of the hyperlink.</span><br />  <span class="rem">// Control.UniqueIDWithDollars is used by</span><br />  <span class="rem">// GetPostBackClientHyperlink to get the EventTarget</span><br />  <span class="kwrd">string</span> UniqueIDWithDollars = Link.UniqueID;<br /><br />  <span class="kwrd">if</span> (UniqueIDWithDollars != <span class="kwrd">null</span><br />    &amp;&amp; UniqueIDWithDollars.IndexOf(<span class="str">':'</span>) &gt;= 0)<br />    UniqueIDWithDollars =<br />      UniqueIDWithDollars.Replace(<span class="str">':'</span>, <span class="str">'$'</span>);<br /><br />  <span class="rem">// Add the CommandName onto the EventTarget,</span><br />  <span class="rem">// using '=' to designate it</span><br />  <span class="kwrd">return</span> PostBack.Replace(<br />    UniqueIDWithDollars,<br />    UniqueIDWithDollars + <span class="str">'='</span> + Link.CommandName);<br />}<br /></pre><br />What we’ve done is inject our CommandName into the __EVENTTARGET portion of the __doPostBack hyperlink.  And then we’ve put our CommandArgument into the otherwise empty __EVENTARGUMENT parameter.  This will result in a hyperlink such as the following:<br /><br /><pre class="csharpcode" style="color:blue;">    javascript:__doPostBack('dgGrid$_ctl2$_ctl0=Edit','1')</pre><br />This hyperlink tells us that within our DataGrid with ID of ‘dgGrid’, we’ve got a control with a CommandName of ‘Edit’ and a CommandArgument of ‘1’.<br /><br />Okay, so we’ve persisted our CommandName and CommandArgument into the JavaScript in the rendered HTML.  Now what?  Well, now we need to capture postbacks that were raised by these special postback events.  This is where we need to handle the DataGrid.Load event.<br /><br /><pre class="csharpcode"><span class="rem">/// &lt;summary&gt;</span><br /><span class="rem">/// On Load, search for any events we need to fire if</span><br /><span class="rem">/// viewstate was disabled last render</span><br /><span class="rem">/// &lt;/summary&gt;</span><br /><span class="rem">/// &lt;param name="sender"&gt;&lt;/param&gt;</span><br /><span class="rem">/// &lt;param name="e"&gt;&lt;/param&gt;</span><br /><span class="kwrd">private</span> <span class="kwrd">void</span> DataGrid_Load(<span class="kwrd">object</span> sender, EventArgs e)<br />{<br />  <span class="rem">// We only care about postbacks when we didn't have</span><br />  <span class="rem">// viewstate on the previous render</span><br />  <span class="kwrd">if</span> (Page.IsPostBack &amp;&amp; !WasUsingViewState())<br />  {<br />    <span class="rem">// The page is posting back and we didn't have</span><br />    <span class="rem">// viewstate.  Get the event target of the postback</span><br />    <span class="kwrd">string</span> EventTarget =<br />      <span class="kwrd">this</span>.Page.Request.Form[_EventTarget];<br /><br />    <span class="rem">// If the event target starts with our ID then we</span><br />    <span class="rem">// know that we fired the postback</span><br />    <span class="kwrd">if</span> (EventTarget != <span class="kwrd">null</span><br />      &amp;&amp; EventTarget.StartsWith(<span class="kwrd">this</span>.ClientID))<br />    {<br />      <span class="rem">// Get the command name from the event target and</span><br />      <span class="rem">// the command argument from event argument</span><br />      <span class="kwrd">string</span> CommandName = GetCommandName(EventTarget);<br />      <span class="kwrd">string</span> CommandArgument =<br />        <span class="kwrd">this</span>.Page.Request.Form[_EventArgument];<br /><br />      <span class="rem">// Fire the bubble event, which will handle</span><br />      <span class="rem">// sort commands, edit commands, etc.</span><br />      <span class="kwrd">this</span>.OnBubbleEvent(<span class="kwrd">this</span>, <span class="kwrd">new</span><br />        System.Web.UI.WebControls.DataGridCommandEventArgs(<br />        <span class="kwrd">null</span>, <span class="kwrd">this</span>,<span class="kwrd">new</span><br />        System.Web.UI.WebControls.CommandEventArgs(<br />        CommandName, CommandArgument)));<br />    }<br />  }<br />}<br /></pre><br />The Load event checks to see if the page was posted back from a control within the DataGrid.  And we only do this processing if we’re not using ViewState.  When we identify an event that needs to be raised, we raise it using the OnBubbleEvent routine.  OnBubbleEvent does all of the work for determining of the SortCommand, EditCommand, SaveCommand, etc. need to be fired.  So we don’t have to worry about any of that, we just fire and forget!<br /><br />We did use a GetCommandName function above that extracts the CommandName from the __EVENTTARGET for us.  That routine is pretty straight-forward.<br /><br /><pre class="csharpcode"><span class="rem">/// &lt;summary&gt;</span><br /><span class="rem">/// Get the command name from the event target value</span><br /><span class="rem">/// &lt;/summary&gt;</span><br /><span class="rem">/// &lt;param name="EventTarget"&gt;&lt;/param&gt;</span><br /><span class="rem">/// &lt;returns&gt;&lt;/returns&gt;</span><br /><span class="kwrd">private</span> <span class="kwrd">string</span> GetCommandName(<span class="kwrd">string</span> EventTarget)<br />{<br />  <span class="rem">// Make sure that we have our designator to identify</span><br />  <span class="rem">// our command name</span><br />  <span class="kwrd">if</span> (EventTarget.IndexOf(<span class="str">'='</span>) &gt; 0)<br />    <span class="kwrd">return</span> EventTarget.Substring(EventTarget.IndexOf(<span class="str">'='</span>) + 1);<br />  <span class="kwrd">else</span><br />    <span class="kwrd">return</span> <span class="kwrd">null</span>;<br />}<br /></pre><br />Just find the token that follows the designator that we set up for adding the CommandName to the end of the __EVENTTARGET.<br /><br />Well, that’s it!  By putting this logic into our DataGrid control, any page can turn off ViewState, and all LinkButton commands can be fired and captured.  There is one disclaimer though.<br /><br />Back to our original #1 problem.  We don’t have the DataGrid Items anymore.  This means that when the ItemCommand is fired, we had to pass in a null reference to the actual source item.  So you won’t be able to use e.Item when you handle the ItemCommand.  If you need to access e.Item.ItemIndex or whatnot, you’ll have to keep ViewState on.  But maybe the real solution to this is to code the screen in a manner that you won’t need to rely on e.Item.  You can actually manufacture a CommandArgument with a delimited list of values, with whatever you want inside of it.  Then you could get whatever properties you want for the item that was clicked.<br /><br />I had tried 3 times to solve this problem previously, with the first attempt resulting in the Statsworld “SuperGrid”.  That effort proved that this concept could work, but I had not been able to re-apply the JavaScript persistence technique to a true DataGrid until now.  I’m pretty pumped as I expect this to allow me to turn ViewState off for the majority of the DataGrids in my current project.  I expect the events to fire just fine everywhere, but testing will need to be done to ensure each screen wasn’t relying on ViewState for the DataGrid for some other display function.<br /><br />I have posted the full code <a href="http://www.jeffhandley.com/Presentations/DataGrid.zip">here</a>.  Enjoy!<br /><hr><br />[5/26/2006 2:30pm]<br />I wanted to give a call out to <a href="http://www.alexandre-gomes.com/" target="gomes">Alexandre Gomes</a>.  <a href="http://www.alexandre-gomes.com/?p=50" target="gomes">His post discussing SetRenderMethodDelegate</a> sparked the idea for me to use this routine to override the LinkButton rendering.  Before that, my implementation for this was project-specific and spanning multiple controls.  I'm super-pumped that I now have a generic solution that is baked entirely into the DataGrid.  Thanks Alexandre!<br /><br />Also, I am going to convert the DataGrid code to VB and I'll get it added into the zip file later today.<br /><hr><br />[5/26/2006 3:50pm]<br />While converting the code to VB, I found a bug... but a minor one.  In some cases of programmatically altering the EnableViewState setting of the datagrid, on postback, the grid thought that viewstate was turned on, but it wasn't during the previous rendering.  So I added a routine for WasUsingViewState and a mechanism for flagging whether or not viewstate was enabled during the previous render.<br /><br />I have updated the code above as well as the <a href="http://www.jeffhandley.com/Presentations/DataGrid.zip">zip file's</a> contents.  And the zip now contains the VB code too.