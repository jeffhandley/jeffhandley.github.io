---
layout: post
title: "RIA Services Validation: Providing ValidationContext"
date: 2010-10-25 07:49:27 -0700
comments: true
category: Archive
tags: []
redirect_from: ["/archive/2010/10/25/RiaServicesValidationContext.aspx", "/archive/2010/10/25/riaservicesvalidationcontext.aspx"]
author: 0
---
<!-- more -->
<p>Throughout this series on <a title="View the list of posts in the RIA Services Validation series" href="http://jeffhandley.com/tags/RiaServicesValidation/default.aspx" target="_blank">RIA Services Validation</a>, I’ve mentioned and shown <a title="MSDN: ValidationContext Class" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationcontext.aspx" target="_blank">ValidationContext</a> several times.  In this post, we’ll learn about the purpose of ValidationContext, what types of context it can provide, and how it integrates with RIA Services.  This will allow us to explore further topics such as cross-entity validation and open the door for other advanced validation scenarios.</p>  <h3>ValidationContext Purpose</h3>  <p>Although ValidationContext exists within the <a title="MSDN: System.ComponentModel.DataAnnotations Namespace" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.aspx" target="_blank">System.ComponentModel.DataAnnotations</a> assembly in both .NET 4.0+ and Silverlight 3+, the class was introduced by the RIA Services team.  While designing the RIA Services validation system, we considered scenarios where validation logic is based on factors outside the validation method itself.  This can range from the user’s settings to UI state to other records within the system.  In addition to the object and property a validator is being executed against, validators much be able to reach back into the system to extract whatever data is needed.</p>  <p>Every time RIA Services <a title="RIA Services Validation: Validation Triggers" href="http://jeffhandley.com/archive/2010/10/06/RiaServicesValidationTriggers.aspx" target="_blank">invokes validation</a>, a ValidationContext is provided to every validator.  With this, validators can access state and services two ways: 1) With an Items property bag that can store any state necessary, and 2) By retrieving services made available by the application.</p>  <h4>Items Dictionary</h4>  <p>ValidationContext offers a <a title="MSDN: ValidationContext.Items Property" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationcontext.items.aspx" target="_blank">Dictionary&lt;object, object&gt; Items property</a> that can be used as an arbitrary property bag.  Any state needed by your validators can be stored and accessed here.  Examples might be the current user of the system (so that a user’s role can affect validation logic), user preference settings, or anything else specific to how the user is interacting with the system.  Think about all of the places where your views track some type of state that drives validation logic – that state can be stored in ValidationContext.Items so that your validators can access it easily.</p>  <h4>IServiceProvider and IServiceContainer</h4>  <p>Consider the scenario where a validator needs to access the database; you certainly wouldn’t couple a validation method to your data access layer, would you?  Instead, you would make your repository available as a service that your validation method can consume in a loosely-coupled manner.  In order to easily support these scenarios, ValidationContext implements <a title="MSDN: IServiceProvider Interface" href="http://msdn.microsoft.com/en-us/library/system.iserviceprovider.aspx" target="_blank">IServiceProvider</a>.  This interface requires a single method, GetService(Type).  Using <a title="MSDN: ValidationContext.GetService Method" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationcontext.getservice.aspx" target="_blank">GetService</a>, a validation method can access your repository without knowing how to instantiate or initialize it.</p>  <p>Although Silverlight doesn’t provide an <a title="MSDN: IServiceContainer Interface" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.design.iservicecontainer.aspx" target="_blank">IServiceContainer</a> interface, the .NET framework does.  On the server, ValidationContext utilizes this interface and exposes a <a title="MSDN: ValidationContext.ServiceContainer Property" href="http://msdn.microsoft.com/en-us/library/system.componentmodel.dataannotations.validationcontext.servicecontainer.aspx" target="_blank">ServiceContainer property</a> that can be used for registering services.  Any service registered through ValidationContext.ServiceContainer will be available through ValidationContext.GetService.</p>  <h4>ValidationContext Constructor</h4>  <p>The ValidationContext class has a <a title="MSDN: ValidationContext Constructor" href="http://msdn.microsoft.com/en-us/library/dd538582.aspx" target="_blank">single constructor</a> accepting the object instance to be validated, an IServiceProvider, and an Items dictionary.  When you are constructing a ValidationContext, you can supply null for the service provider and/or items dictionary if you aren’t using them.</p>  <p>When validation is about to be invoked for a value, it’s necessary that the object instance provided to the ValidationContext constructor matches the ObjectInstance being validated.  However, when constructing a ValidationContext that will be used as a seed for future validation (as we’re discussing in this post), the object provided to the constructor is unimportant and arbitrary.</p>  <p>If you supply an IServiceProvider, any calls to ValidationContext.GetService will utilize that provider.  If you pass null for the service provider, GetService will not use any backing store – but using ValidationContext.ServiceContainer.AddService still allows you to provide services individually.</p>  <p>If you supply an IDictionary&lt;object, object&gt; for the items parameter, ValidationContext.Items will utilize this dictionary as the seed.  Additional items can be added after construction, but if you have a prepared dictionary, you can specify it easily.  If you pass null for the items, then an empty dictionary will be created as the seed.</p>  <p>With both your Services and Items, anything you provide will be used as a seed for future validation.  Each invocation of validation will in fact use a new instance of ValidationContext, but your Items and Services are re-used.</p>  <h3>RIA Services Integration</h3>  <p>Of course, in order for validators to get any use out of ValidationContext, RIA Services needs to offer a means for putting items and services <em>into</em> ValidationContext.  The approaches for this differ between the server (DomainService) and the client (DomainContext) because the calls are made in different ways.</p>  <h4>DomainService (Server-Side)</h4>  <p>Your <a title="MSDN: DomainService Class" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.server.domainservice(VS.91).aspx" target="_blank">DomainService</a> is a near-stateless service.  Every time your service is invoked on the server, a new instance of your DomainService is instantiated and executed.  When the request ends, the DomainService is disposed.  Your DomainService is the gateway into your back-end system, and therefore it’s expected that this class would have access to all state related to validation as well as any services that validation might rely on.  To provide state and services, the DomainService class has a <em>protected</em> read/write property for <a title="MSDN: DomainService.ValidationContext Property" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.server.domainservice.validationcontext(VS.91).aspx" target="_blank">ValidationContext</a>.</p>  <p>The intent with this design is that your DomainService can construct its custom ValidationContext, providing any Items or Services, and set the ValidationContext property on the DomainService during the <a title="MSDN: DomainService.Initialize Method" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.server.domainservice.initialize(VS.91).aspx" target="_blank">Initialize</a> method.  Here’s an example of a MeetingService that does this:</p>  <pre style="font-family: "><font face="Consolas"><font size="1"><font color="#000000">    [</font><span style="color: "><font color="#2b91af">EnableClientAccess</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">()]<br />    </font><span style="color: "><font color="#0000ff">public</font></span><font color="#000000"> </font><span style="color: "><font color="#0000ff">class</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">MeetingService</font></span><font color="#000000"> : </font><span style="color: "><font color="#2b91af">LinqToEntitiesDomainService</font></span><font color="#000000">&lt;</font><span style="color: "><font color="#2b91af">MeetingStoreEntities</font></span><font color="#000000">&gt;, </font><span style="color: "><font color="#2b91af">IMeetingDataProvider</font></span><br /></font></font><font face="Consolas"><font size="1"><font color="#000000">    {<br />        </font><span style="color: "><font color="#808080">///</font></span><span style="color: "><font color="#008000"> </font></span><span style="color: "><font color="#808080">&lt;summary&gt;</font></span><br /><font color="#000000">        </font><span style="color: "><font color="#808080">///</font></span><span style="color: "><font color="#008000"> Initialize the </font></span><font color="#808080"><span style="color: ">&lt;see cref=</span><span style="color: ">"DomainService"</span><span style="color: ">/&gt;</span></font><span style="color: "><font color="#008000">, setting the</font></span><br /><font color="#000000">        </font><span style="color: "><font color="#808080">///</font></span><span style="color: "><font color="#008000"> </font></span><font color="#808080"><span style="color: ">&lt;see cref=</span><span style="color: ">"ValidationContext"</span><span style="color: ">/&gt;</span></font><span style="color: "><font color="#008000"> with custom state and services.</font></span><br /><font color="#000000">        </font><span style="color: "><font color="#808080">///</font></span><span style="color: "><font color="#008000"> </font></span><span style="color: "><font color="#808080">&lt;/summary&gt;</font></span><br /></font></font><font face="Consolas"><font color="#000000"><font size="1">        </font></font><font size="1"><span style="color: "><font color="#808080">///</font></span><span style="color: "><font color="#008000"> </font></span><font color="#808080"><span style="color: ">&lt;param name=</span><span style="color: ">"context"</span><span style="color: ">&gt;</span></font><br /><font color="#000000">        </font><span style="color: "><font color="#808080">///</font></span><span style="color: "><font color="#008000"> Represents the execution environment for the operations performed</font></span><br /><font color="#000000">        </font><span style="color: "><font color="#808080">///</font></span><span style="color: "><font color="#008000"> by a System.ServiceModel.DomainServices.Server.DomainService.</font></span><br /><font color="#000000">        </font><span style="color: "><font color="#808080">///</font></span><span style="color: "><font color="#008000"> </font></span><span style="color: "><font color="#808080">&lt;/param&gt;</font></span></font></font><br /><font face="Consolas"><font size="1"><span style="color: "><font color="#0000ff">        public</font></span><font color="#000000"> </font><span style="color: "><font color="#0000ff">override</font></span><font color="#000000"> </font><span style="color: "><font color="#0000ff">void</font></span><font color="#000000"> Initialize(</font><span style="color: "><font color="#2b91af">DomainServiceContext</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000"> context)<br />        {<br />            </font><span style="color: "><font color="#0000ff">var</font></span><font color="#000000"> contextItems = </font><span style="color: "><font color="#0000ff">new</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">Dictionary</font></span><font color="#000000">&lt;</font><span style="color: "><font color="#0000ff">object</font></span><font color="#000000">, </font><span style="color: "><font color="#0000ff">object</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">&gt;<br />            {<br />                { </font><span style="color: "><font color="#a31515">"AllowOverBooking"</font></span><font color="#000000">, </font><span style="color: "><font color="#2b91af">HttpContext</font></span><font color="#000000">.Current.Session[</font><span style="color: "><font color="#a31515">"AllowOverBooking"</font></span><font color="#000000">] ?? </font><span style="color: "><font color="#0000ff">false</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000"> }<br />            };<br /> <br />            </font><span style="color: "><font color="#0000ff">this</font></span><font color="#000000">.ValidationContext = </font><span style="color: "><font color="#0000ff">new</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">ValidationContext</font></span><font color="#000000">(</font><span style="color: "><font color="#0000ff">this</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">, context, contextItems);<br />            </font><span style="color: "><font color="#0000ff">this</font></span><font color="#000000">.ValidationContext.ServiceContainer.AddService(</font><span style="color: "><font color="#0000ff">typeof</font></span><font color="#000000">(</font><span style="color: "><font color="#2b91af">IMeetingDataProvider</font></span><font color="#000000">), </font><span style="color: "><font color="#0000ff">this</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">);<br /> <br />            </font><span style="color: "><font color="#0000ff">base</font></span></font><font color="#000000" size="1">.Initialize(context);<br />        }</font></font></pre>

<pre style="font-family: "><font size="1"><font color="#000000" face="Consolas">    ...</font><br /></font></pre>

<p>The Initialize method is the perfect place to provide the customized ValidationContext for a few reasons.  First, this method is always called before any validation occurs.  Second, the <a title="MSDN: DomainServiceContext Class" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.server.domainservicecontext(VS.91).aspx" target="_blank">DomainServiceContext</a> is provided, which offers context about the domain service operation being performed, allowing the ValidationContext to be altered based on that state.  And third, DomainServiceContext implements IServiceProvider and can therefore be used as the seed of services to be provided to the ValidationContext—any services available to your DomainService are now also available to your validation methods.</p>

<p>Beyond the services already available from the DomainServiceContext, you can register additional services using the ValidationContext.ServiceContainer.AddService method.  In this example, the DomainService is making itself available as an IMeetingDataProvider instance.  We’ll learn more about how this is used in the next blog post.</p>

<h4>DomainContext (Client-Side)</h4>

<p>On the client, our validation methods are called a bit differently from the server.  Whereas on the server we had a near-stateless service, the client has a very stateful <a title="MSDN: DomainContext Class" href="http://msdn.microsoft.com/query/dev10.query?appId=Dev10IDEF1&amp;l=EN-US&amp;k=k(SYSTEM.SERVICEMODEL.DOMAINSERVICES.CLIENT.DOMAINCONTEXT)&amp;rd=true" target="_blank">DomainContext</a>.  Our DomainContext serves as our client-side cache of entities, and the proxy to invoke server-side operations.  The lifetime of a DomainContext can be very long, in fact some scenarios have a DomainContext stay alive for the entire lifetime of the application.  Your client application <em>consumes and operates on</em> your DomainContext, but your DomainContext does not control your application state or logic, and therefore it should not be in control of the ValidationContext either.</p>

<p>To accommodate the client-side usage scenarios for validation context, you’ll see that every DomainContext has a <em><strong>public</strong></em> read/write <a title="MSDN: DomainContext.ValidationContext Property" href="http://msdn.microsoft.com/en-us/library/system.servicemodel.domainservices.client.domaincontext.validationcontext(VS.91).aspx" target="_blank">ValidationContext property</a>.  Emphasis on <strong><em>public</em></strong>.  This means that any consumer of your DomainContext can set the ValidationContext property at any time, or add items into its Items dictionary at any time.  Moreover, consumers of your DomainContext control what services are available from the ValidationContext.GetService by supplying a custom IServiceProvider argument on the ValidationContext constructor.</p>

<p>Your DomainContext consumers will be your Views, or more optimistically, your ViewModels.  Here’s some code that creates a custom ValidationContext and sets it on a MeetingContext instance:</p>

<pre style="font-family: "><font face="Consolas"><font size="1"><font color="#000000">    </font><span style="color: "><font color="#0000ff">var</font></span><font color="#000000"> contextItems = </font><span style="color: "><font color="#0000ff">new</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">Dictionary</font></span><font color="#000000">&lt;</font><span style="color: "><font color="#0000ff">object</font></span><font color="#000000">, </font><span style="color: "><font color="#0000ff">object</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">&gt;<br />    {<br />        { </font><span style="color: "><font color="#a31515">"AllowOverBooking"</font></span><font color="#000000">, </font><span style="color: "><font color="#0000ff">this</font></span><font color="#000000">.allowOverBooking.IsChecked ?? </font><span style="color: "><font color="#0000ff">false</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000"> }<br />    };<br /> <br />    </font><span style="color: "><font color="#0000ff">var</font></span><font color="#000000"> contextServiceProvider = </font><span style="color: "><font color="#0000ff">new</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">SimpleServiceProvider</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">();<br />    contextServiceProvider.AddService&lt;</font><span style="color: "><font color="#2b91af">IMeetingDataProvider</font></span><font color="#000000">&gt;(</font><span style="color: "><font color="#0000ff">this</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">.meetingContext);<br /> <br />    </font><span style="color: "><font color="#0000ff">this</font></span><font color="#000000">.meetingContext.ValidationContext = </font><span style="color: "><font color="#0000ff">new</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">ValidationContext</font></span></font></font><font size="1"><font face="Consolas"><font color="#000000">(<br />        </font><span style="color: "><font color="#0000ff">this</font></span><font color="#000000">.meetingContext, contextServiceProvider, contextItems);</font></font><br /></font></pre>

<p>There are two major differences on the client:</p>

<ol>
  <li>There is no IServiceProvider instance given to you, nor is there a concrete implementation, so you’ll have to create one; </li>

  <li>There is no IServiceContainer interface and no ServiceContainer property on ValidationContext, so you cannot add services after creating your ValidationContext. </li>
</ol>

<p>Here is the world’s simplest IServiceProvider implementation, and it’s what I have used several times:</p>

<pre style="font-family: "><font face="Consolas"><font color="#000000"><font size="1">    </font></font><font size="1"><span style="color: "><font color="#0000ff">public</font></span><font color="#000000"> </font><span style="color: "><font color="#0000ff">class</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">SimpleServiceProvider</font></span><font color="#000000"> : </font><span style="color: "><font color="#2b91af">IServiceProvider</font></span><br /></font></font><font face="Consolas"><font size="1"><font color="#000000">    {<br />        </font><span style="color: "><font color="#0000ff">private</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">Dictionary</font></span><font color="#000000">&lt;</font><span style="color: "><font color="#2b91af">Type</font></span><font color="#000000">, </font><span style="color: "><font color="#0000ff">object</font></span><font color="#000000">&gt; _services = </font><span style="color: "><font color="#0000ff">new</font></span><font color="#000000"> </font><span style="color: "><font color="#2b91af">Dictionary</font></span><font color="#000000">&lt;</font><span style="color: "><font color="#2b91af">Type</font></span><font color="#000000">, </font><span style="color: "><font color="#0000ff">object</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">&gt;();<br /> <br />        </font><span style="color: "><font color="#0000ff">public</font></span><font color="#000000"> </font><span style="color: "><font color="#0000ff">object</font></span><font color="#000000"> GetService(</font><span style="color: "><font color="#2b91af">Type</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000"> serviceType)<br />        {<br />            </font><span style="color: "><font color="#0000ff">if</font></span><font color="#000000"> (</font><span style="color: "><font color="#0000ff">this</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">._services.ContainsKey(serviceType))<br />            {<br />                </font><span style="color: "><font color="#0000ff">return</font></span><font color="#000000"> </font><span style="color: "><font color="#0000ff">this</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">._services[serviceType];<br />            }<br /> <br />            </font><span style="color: "><font color="#0000ff">return</font></span><font color="#000000"> </font><span style="color: "><font color="#0000ff">null</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000">;<br />        }<br /> <br />        </font><span style="color: "><font color="#0000ff">public</font></span><font color="#000000"> </font><span style="color: "><font color="#0000ff">void</font></span></font></font><font face="Consolas"><font size="1"><font color="#000000"> AddService&lt;T&gt;(T service)<br />        {<br />            </font><span style="color: "><font color="#0000ff">this</font></span><font color="#000000">._services[</font><span style="color: "><font color="#0000ff">typeof</font></span></font><font color="#000000" size="1">(T)] = service;<br />        }<br />    }</font></font><br /></pre>

<p> </p>

<p>Once the ValidationContext property has been set on your DomainContext, all validation invoked through the DomainContext or through any Entity attached to the DomainContext will use this ValidationContext as the seed.</p>

<h4>Detached Entities, DataGrid, and DataForm (Beware of the gaps)</h4>

<p>On the client, there are some gaps in ValidationContext’s use.  The first is with detached entities—because the ValidationContext is provided to a DomainContext, any validation performed by an entity before it’s attached to a DomainContext will not have access to the custom ValidationContext you supply.  This is very obvious when you instantiate a new entity and set its properties immediately; property-level validation occurring at that time will not have access to your Items or Services.  As soon as you attach the entity to your DomainContext though, this connection is made.</p>

<p>DataGrid and DataForm are controls in the Silverlight SDK and Toolkit respectively.  These controls have no dependency on RIA Services (or vice versa), even though they integrate with RIA Services very well.  Because there is no dependency on RIA Services, there is no means for the controls to access your DomainContext or its ValidationContext.  Therefore it’s important to understand that any validation invoked by these controls <strong>will not have access</strong> to your Items and Services.  But worry not, when your entities are attached to your DomainContext, the property setters themselves invoke validation using your ValidationContext.  Similarly, entities validate themselves when you finish editing them and your ValidationContext is used then too.  Lastly, when you call SubmitChanges(), your entire changeset is validated again, and the ValidationContext is available then too.</p>

<p>What you must take away from this is that <strong><em>your validation methods cannot assume access to your ValidationContext Items and Services.</em></strong>  You must author your client-side validation methods such that they succeed when any required items or services are unavailable.  We’ll see concrete examples of this in the next blog post. </p>

<h3>RIA Services Validation Recap</h3>

<p>In this article, we’ve learned how RIA Services uses ValidationContext as a mechanism for your applications to register state and services for use by validation methods.  Your DomainService can set its own ValidationContext from the Initialize method and all server-side validation will use this context.  Your client-side application code can set the ValidationContext on the DomainContext instances used and offer state and services as well.  On the client, not every invocation of validation will have access to the state and services though, so validation methods must be able to fall back to success.</p>

<p>This article is part of an in-depth series on RIA Services Validation.  Here’s the full series:</p>

<ol>
  <ol>
    <li><a href="http://jeffhandley.com/archive/2010/09/22/RiaServicesStandardValidators.aspx">Standard Validators</a></li>

    <li><a href="http://jeffhandley.com/archive/2010/09/25/RiaServicesCustomValidationMethods.aspx">Custom Validation Methods</a></li>

    <li><a href="http://jeffhandley.com/archive/2010/09/26/RiaServicesCustomReusableValidators.aspx">Custom Reusable Validators</a></li>

    <li><a href="http://jeffhandley.com/archive/2010/09/30/RiaServicesValidationAttributePropagation.aspx">Attribute Propagation</a></li>

    <li><a href="http://jeffhandley.com/archive/2010/10/06/RiaServicesValidationTriggers.aspx">Validation Triggers</a></li>

    <li><a href="http://jeffhandley.com/archive/2010/10/10/CrossFieldValidation.aspx">Cross-Field Validation</a></li>

    <li><a href="http://jeffhandley.com/archive/2010/10/12/EntityLevelValidation.aspx">Entity-Level Validation</a></li>

    <li><a href="http://jeffhandley.com/archive/2010/10/25/RiaServicesValidationContext.aspx">Providing ValidationContext</a></li>

    <li><a href="http://jeffhandley.com/archive/2010/10/25/CrossEntityValidation.aspx">Using ValidationContext (Cross-Entity Validation)</a></li>

    <li><a href="http://jeffhandley.com/archive/2011/09/06/ViewModelValidation.aspx">ViewModel Validation with Entity Rules</a></li>
  </ol>
</ol>

<p><strong><em>[9/6/2011] The source code for everything shown during the series is <a href="http://jeffhandley.com/archive/2011/09/06/RIA-Services-Validation-Available-on-GitHub.aspx">available on GitHub</a>.</em></strong></p>

<h3>Digging Deeper</h3>

<p>In the next post, we’ll see some examples of how to leverage the ValidationContext that we just learned about.  The examples will include a couple of cross-entity validation scenarios.  After that, I’ll provide a validator factory that allows validation rules from entities to be inherited into a ViewModel.</p>

<div style="padding-bottom: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; float: none; padding-top: 0px" id="scid:0767317B-992E-4b12-91E0-4F059A8CECA8:ae56798a-0bda-4fbe-91be-3a3266ea8812" class="wlWriterEditableSmartContent">Technorati Tags: <a href="http://technorati.com/tags/RiaServicesValidation" rel="tag">RiaServicesValidation</a>,<a href="http://technorati.com/tags/RiaServices" rel="tag">RiaServices</a>,<a href="http://technorati.com/tags/Validation" rel="tag">Validation</a>,<a href="http://technorati.com/tags/Silverlight" rel="tag">Silverlight</a>,<a href="http://technorati.com/tags/DataAnnotations" rel="tag">DataAnnotations</a></div>

